<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE register_page SYSTEM "registers.dtd">
<!-- Copyright (c) 2010-2025 Arm Limited or its affiliates. All rights reserved. -->
<!-- This document is Non-Confidential. This document may only be used and distributed in accordance with the terms of the agreement entered into by Arm and the party that Arm delivered this document to. -->
<!--The data contained in this document is preliminary and subject to change or correction following further review. -->
<?xml-stylesheet href="one_register.xsl" type="text/xsl" ?>







<register_page>
  <registers>
  
    <register execution_state="AArch64" is_register="True" is_internal="True" is_stub_entry="False">
      <reg_short_name>PMCR_EL0</reg_short_name>
        
        <reg_long_name>Performance Monitors Control Register</reg_long_name>



      
            <reg_condition otherwise="UNDEFINED">when FEAT_PMUv3 is implemented and FEAT_AA64 is implemented</reg_condition>
      




          <reg_reset_value></reg_reset_value>

      <reg_mappings>
        



    
      
      <reg_mapping>
        
  

    

  

    <mapped_name filename="AArch32-pmcr.xml">PMCR</mapped_name>
  <mapped_type>Architectural</mapped_type>
      <mapped_execution_state>AArch32</mapped_execution_state>
    <mapped_from_startbit>31</mapped_from_startbit>
    <mapped_from_endbit>0</mapped_from_endbit>
    <mapped_to_startbit>31</mapped_to_startbit>
    <mapped_to_endbit>0</mapped_to_endbit>
    <mapped_from_rangeset output="31:0">
      <range>
        <msb>31</msb>
        <lsb>0</lsb>
      </range>
    </mapped_from_rangeset>
    <mapped_to_rangeset output="31:0">
      <range>
        <msb>31</msb>
        <lsb>0</lsb>
      </range>
    </mapped_to_rangeset>

      </reg_mapping>
    
      
      <reg_mapping>
        
  

    

  

    <mapped_name filename="pmu.pmcr_el0.xml">PMCR_EL0</mapped_name>
  <mapped_type>Architectural</mapped_type>
    <mapped_execution_state>External</mapped_execution_state>
    <mapped_from_startbit>31</mapped_from_startbit>
    <mapped_from_endbit>0</mapped_from_endbit>
    <mapped_to_startbit>31</mapped_to_startbit>
    <mapped_to_endbit>0</mapped_to_endbit>
    <mapped_from_rangeset output="31:0">
      <range>
        <msb>31</msb>
        <lsb>0</lsb>
      </range>
    </mapped_from_rangeset>
    <mapped_to_rangeset output="31:0">
      <range>
        <msb>31</msb>
        <lsb>0</lsb>
      </range>
    </mapped_to_rangeset>

      </reg_mapping>
    
      
      <reg_mapping>
        
  

    

  

    <mapped_name filename="pmu.pmcr_el0.xml">PMCR_EL0</mapped_name>
  <mapped_type>Architectural</mapped_type>
    <mapped_execution_state>External</mapped_execution_state>
    <mapped_from_startbit>63</mapped_from_startbit>
    <mapped_from_endbit>32</mapped_from_endbit>
    <mapped_to_startbit>63</mapped_to_startbit>
    <mapped_to_endbit>32</mapped_to_endbit>
    <mapped_from_rangeset output="63:32">
      <range>
        <msb>63</msb>
        <lsb>32</lsb>
      </range>
    </mapped_from_rangeset>
    <mapped_to_rangeset output="63:32">
      <range>
        <msb>63</msb>
        <lsb>32</lsb>
      </range>
    </mapped_to_rangeset>

        <mapped_to_condition>when FEAT_PMUv3_EXT64 is implemented</mapped_to_condition>
      </reg_mapping>

      </reg_mappings>

        <reg_purpose>
          
    
      <purpose_text>
        <para>Provides details of the Performance Monitors implementation, including the number of counters implemented, and configures and controls the counters.</para>
      </purpose_text>

        </reg_purpose>

      <reg_groups>
          <reg_group>PMU</reg_group>
      </reg_groups>
      
      
        
      <reg_attributes>
          
    
      <attributes_text>
        <para>PMCR_EL0 is a 64-bit register.</para>
      </attributes_text>

      </reg_attributes>
      <reg_fieldsets>
        





<fields id="fieldset_0" length="64">
  <text_before_fields/>
  <field id="fieldset_0-63_33" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0">
    <field_msb>63</field_msb>
    <field_lsb>33</field_lsb>
    <rel_range>63:33</rel_range>
    <field_description order="before"/>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
  </field>
  <field id="fieldset_0-32_32-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" reserved_type="RES0">
    <field_name>FZS</field_name>
    <field_msb>32</field_msb>
    <field_lsb>32</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Freeze-on-SPE event. Stop counters when <register_link state="AArch64" id="AArch64-pmblimitr_el1.xml">PMBLIMITR_EL1</register_link>.{PMFZ,E} is {1,1} and profiling is stopped.</para>
    </field_description>
    <field_description order="after"><para>The pseudocode function <function>SPEProfilingStopped</function> describes when profiling is stopped.</para>
<para>The counters affected by this field are:</para>
<list type="unordered">
<listitem><content>The event counters in the first range.</content>
</listitem><listitem><content>If <xref linkend="#FEAT_PMUv3_ICNTR">FEAT_PMUv3_ICNTR</xref> is implemented, the instruction counter <register_link state="AArch64" id="AArch64-pmicntr_el0.xml">PMICNTR_EL0</register_link>.</content>
</listitem><listitem><content>If <xref linkend="#FEAT_SPE_DPFZS">FEAT_SPE_DPFZS</xref> is implemented and PMCR_EL0.DP is 1, the cycle counter <register_link state="AArch64" id="AArch64-pmccntr_el0.xml">PMCCNTR_EL0</register_link>.</content>
</listitem></list>
<para>Other event counters are not affected by this field.</para>
<para>When <xref linkend="#FEAT_SPE_DPFZS">FEAT_SPE_DPFZS</xref> is not implemented or PMCR_EL0.DP is 0, <register_link state="AArch64" id="AArch64-pmccntr_el0.xml">PMCCNTR_EL0</register_link> is not affected by this field.</para>
<para>For more information about event counter ranges, see <register_link state="AArch64" id="AArch64-mdcr_el2.xml">MDCR_EL2</register_link>.HPMN.</para></field_description>
    <field_values impdef="False">
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Do not freeze on a Statistical Profiling Buffer Management event.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Affected counters do not count following a Statistical Profiling Buffer Management event.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_conditions>
          <field_reset_condition condition="FEAT_AA32 is implemented">
            <field_reset>
              <field_reset_number>'0'</field_reset_number>
            </field_reset>
          </field_reset_condition>
          <field_reset_condition>
            <field_reset>
              <field_reset_standard_text>AU</field_reset_standard_text>
            </field_reset>
          </field_reset_condition>
        </field_reset_conditions>
      </field_reset>
    </field_resets>
    <fields_condition>When FEAT_SPEv1p2 is implemented</fields_condition>
  </field>
  <field id="fieldset_0-32_32-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0">
    <field_msb>32</field_msb>
    <field_lsb>32</field_lsb>
    <rel_range>32</rel_range>
    <field_description order="before"/>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_0-31_24-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="True" is_partial_field="False" is_conditional_field_name="False" reserved_type="RAZ">
    <field_name>IMP</field_name>
    <field_msb>31</field_msb>
    <field_lsb>24</field_lsb>
    <rel_range>7:0</rel_range>
    <field_description order="before"><para>Implementer code.</para>
<para>If this field is zero, then PMCR_EL0.IDCODE is <arm-defined-word>RES0</arm-defined-word> and software must use <register_link state="AArch64" id="AArch64-midr_el1.xml">MIDR_EL1</register_link> to identify the PE.</para>
<para>Otherwise, this field and PMCR_EL0.IDCODE identify the PMU implementation to software. The implementer codes are allocated by Arm. A nonzero value has the same interpretation as <register_link state="AArch64" id="AArch64-midr_el1.xml">MIDR_EL1</register_link>.Implementer.</para></field_description>
    <field_description order="after"><para>Arm deprecates use of this field.</para>
<para>This field has an <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> value.</para></field_description>
    <field_access>
      <field_access_state>
        <field_access_type>RO</field_access_type>
      </field_access_state>
    </field_access>
    <fields_condition>When FEAT_PMUv3p7 is not implemented</fields_condition>
  </field>
  <field id="fieldset_0-31_24-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RAZ">
    <field_msb>31</field_msb>
    <field_lsb>24</field_lsb>
    <rel_range>31:24</rel_range>
    <field_description order="before"/>
    <field_description order="before">
      <para>Reserved, RAZ.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_0-23_16-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="True" is_partial_field="False" is_conditional_field_name="False" reserved_type="RES0">
    <field_name>IDCODE</field_name>
    <field_msb>23</field_msb>
    <field_lsb>16</field_lsb>
    <rel_range>7:0</rel_range>
    <field_description order="before"><para>Identification code. Arm deprecates use of this field.</para>
<para>Each implementer must maintain a list of identification codes that are specific to the implementer. A specific implementation is identified by the combination of the implementer code and the identification code.</para></field_description>
    <field_description order="after">
      <para>This field has an <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> value.</para>
    </field_description>
    <field_access>
      <field_access_state>
        <field_access_type>RO</field_access_type>
      </field_access_state>
    </field_access>
    <fields_condition>When PMCR_EL0.IMP != 0b00000000</fields_condition>
  </field>
  <field id="fieldset_0-23_16-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0">
    <field_msb>23</field_msb>
    <field_lsb>16</field_lsb>
    <rel_range>23:16</rel_range>
    <field_description order="before"/>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_0-15_11" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="True" is_partial_field="False" is_conditional_field_name="False">
    <field_name>N</field_name>
    <field_msb>15</field_msb>
    <field_lsb>11</field_lsb>
    <rel_range>15:11</rel_range>
    <field_description order="before"><para>Indicates the number of event counters implemented. This value is in the range of <binarynumber>0b00000</binarynumber>-<binarynumber>0b11111</binarynumber>. If the value is <binarynumber>0b00000</binarynumber>, then only <register_link state="AArch64" id="AArch64-pmccntr_el0.xml">PMCCNTR_EL0</register_link> is implemented. If the value is <binarynumber>0b11111</binarynumber>, then <register_link state="AArch64" id="AArch64-pmccntr_el0.xml">PMCCNTR_EL0</register_link> and 31 event counters are implemented.</para>
<para>When EL2 is implemented and enabled for the current Security state, reads of this field from EL1 and EL0 return the Effective value of <register_link state="AArch64" id="AArch64-mdcr_el2.xml">MDCR_EL2</register_link>.HPMN.</para></field_description>
    <field_description order="after">
      <para>This field has an <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> value.</para>
    </field_description>
    <field_access>
      <field_access_state>
        <field_access_type>RO</field_access_type>
      </field_access_state>
    </field_access>
  </field>
  <field id="fieldset_0-10_10" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0">
    <field_msb>10</field_msb>
    <field_lsb>10</field_lsb>
    <rel_range>10</rel_range>
    <field_description order="before"/>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
  </field>
  <field id="fieldset_0-9_9-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" reserved_type="RES0">
    <field_name>FZO</field_name>
    <field_msb>9</field_msb>
    <field_lsb>9</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Freeze-on-overflow. Stop event counters on overflow.</para>
    </field_description>
    <field_description order="after"><para>The counters affected by this field are:</para>
<list type="unordered">
<listitem><content>The event counters in the first range.</content>
</listitem><listitem><content>If <xref linkend="#FEAT_PMUv3_ICNTR">FEAT_PMUv3_ICNTR</xref> is implemented, the instruction counter <register_link state="AArch64" id="AArch64-pmicntr_el0.xml">PMICNTR_EL0</register_link>.</content>
</listitem><listitem><content>If PMCR_EL0.DP is 1, the cycle counter <register_link state="AArch64" id="AArch64-pmccntr_el0.xml">PMCCNTR_EL0</register_link>.</content>
</listitem></list>
<para>Other event counters are not affected by this field.</para>
<para>When PMCR_EL0.DP is 0, <register_link state="AArch64" id="AArch64-pmccntr_el0.xml">PMCCNTR_EL0</register_link> is not affected by this field.</para>
<para>For more information about event counter ranges, see <register_link state="AArch64" id="AArch64-mdcr_el2.xml">MDCR_EL2</register_link>.HPMN.</para></field_description>
    <field_values impdef="False">
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Do not freeze on overflow.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description><para>Affected counters do not count when any of the following applies:</para>
<list type="unordered">
<listitem><content>
<para>For any event counter <register_link id="AArch64-pmevcntrn_el0.xml" state="AArch64">PMEVCNTR&lt;m&gt;_EL0</register_link> in the first range, <register_link state="AArch64" id="AArch64-pmovsclr_el0.xml">PMOVSCLR_EL0</register_link>[m] is 1, and either <xref linkend="#FEAT_SEBEP">FEAT_SEBEP</xref> is not implemented or <register_link id="AArch64-pmevtypern_el0.xml" state="AArch64">PMEVTYPER&lt;m&gt;_EL0</register_link>.SYNC is 0.</para>
</content>
</listitem><listitem><content>
<para><xref linkend="#FEAT_PMUv3_ICNTR">FEAT_PMUv3_ICNTR</xref> is implemented, <register_link state="AArch64" id="AArch64-pmovsclr_el0.xml">PMOVSCLR_EL0</register_link>.F0 is 1, and either <xref linkend="#FEAT_SEBEP">FEAT_SEBEP</xref> is not implemented or <register_link state="AArch64" id="AArch64-pmicfiltr_el0.xml">PMICFILTR_EL0</register_link>.SYNC is 0.</para>
</content>
</listitem></list></field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_standard_text>AU</field_reset_standard_text>
      </field_reset>
    </field_resets>
    <fields_condition>When FEAT_PMUv3p7 is implemented</fields_condition>
  </field>
  <field id="fieldset_0-9_9-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0">
    <field_msb>9</field_msb>
    <field_lsb>9</field_lsb>
    <rel_range>9</rel_range>
    <field_description order="before"/>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_0-8_8" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0">
    <field_msb>8</field_msb>
    <field_lsb>8</field_lsb>
    <rel_range>8</rel_range>
    <field_description order="before"/>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
  </field>
  <field id="fieldset_0-7_7-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" reserved_type="RES0">
    <field_name>LP</field_name>
    <field_msb>7</field_msb>
    <field_lsb>7</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Long event counter enable. Determines when unsigned overflow is recorded by <register_link state="AArch64" id="AArch64-pmovsclr_el0.xml">PMOVSCLR_EL0</register_link>.P[n].</para>
    </field_description>
    <field_description order="after"><para>When <xref linkend="#FEAT_EBEP">FEAT_EBEP</xref> is implemented and the PMU Profiling exception is enabled, the Effective value of this field is 1.</para>
<para>The counters affected by this field are the event counters in the first range.
For more information about event counter ranges, see <register_link state="AArch64" id="AArch64-mdcr_el2.xml">MDCR_EL2</register_link>.HPMN.</para>
<para>Other event counters and <register_link state="AArch64" id="AArch64-pmccntr_el0.xml">PMCCNTR_EL0</register_link> are not affected by this field.</para>
<para>When <xref linkend="#FEAT_PMUv3_ICNTR">FEAT_PMUv3_ICNTR</xref> is implemented, <register_link state="AArch64" id="AArch64-pmicntr_el0.xml">PMICNTR_EL0</register_link> is not affected by this field.</para></field_description>
    <field_values impdef="False">
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Event counter overflow on increment that causes unsigned overflow of <register_link state="AArch64" id="AArch64-pmevcntrn_el0.xml">PMEVCNTR&lt;n&gt;_EL0</register_link>[31:0].</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Event counter overflow on increment that causes unsigned overflow of <register_link state="AArch64" id="AArch64-pmevcntrn_el0.xml">PMEVCNTR&lt;n&gt;_EL0</register_link>[63:0].</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_standard_text>AU</field_reset_standard_text>
      </field_reset>
    </field_resets>
    <fields_condition>When FEAT_PMUv3p5 is implemented</fields_condition>
  </field>
  <field id="fieldset_0-7_7-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0">
    <field_msb>7</field_msb>
    <field_lsb>7</field_lsb>
    <rel_range>7</rel_range>
    <field_description order="before"/>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_0-6_6-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" reserved_type="RES1">
    <field_name>LC</field_name>
    <field_msb>6</field_msb>
    <field_lsb>6</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Long cycle counter enable. Determines when unsigned overflow is recorded by <register_link state="AArch64" id="AArch64-pmovsclr_el0.xml">PMOVSCLR_EL0</register_link>.C.</para>
    </field_description>
    <field_description order="after"><para>When <xref linkend="#FEAT_EBEP">FEAT_EBEP</xref> is implemented and the PMU Profiling exception is enabled, the Effective value of this field is 1.</para>
<para>Arm deprecates use of PMCR_EL0.LC = 0.</para></field_description>
    <field_values impdef="False">
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Cycle counter overflow on increment that causes unsigned overflow of <register_link state="AArch64" id="AArch64-pmccntr_el0.xml">PMCCNTR_EL0</register_link>[31:0].</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Cycle counter overflow on increment that causes unsigned overflow of <register_link state="AArch64" id="AArch64-pmccntr_el0.xml">PMCCNTR_EL0</register_link>[63:0].</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_standard_text>AU</field_reset_standard_text>
      </field_reset>
    </field_resets>
    <fields_condition>When FEAT_AA32 is implemented</fields_condition>
  </field>
  <field id="fieldset_0-6_6-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES1">
    <field_msb>6</field_msb>
    <field_lsb>6</field_lsb>
    <rel_range>6</rel_range>
    <field_description order="before"/>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES1</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_0-5_5-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" reserved_type="RES0">
    <field_name>DP</field_name>
    <field_msb>5</field_msb>
    <field_lsb>5</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Disable cycle counter when event counting is prohibited.</para>
    </field_description>
    <field_description order="after"><para>The conditions when this field disables the cycle counter are the same as when event counting by an event counter  in the first range is prohibited or frozen.
For more information about event counter ranges, see <register_link state="AArch64" id="AArch64-mdcr_el2.xml">MDCR_EL2</register_link>.HPMN.</para>
<para>If <xref linkend="#FEAT_PMUv3p7">FEAT_PMUv3p7</xref> and <xref linkend="#FEAT_SPEv1p2">FEAT_SPEv1p2</xref> are implemented, meaning PMCR_EL0.FZS is implemented, and <xref linkend="#FEAT_SPE_DPFZS">FEAT_SPE_DPFZS</xref> is not implemented, then cycle counting by <register_link state="AArch64" id="AArch64-pmccntr_el0.xml">PMCCNTR_EL0</register_link> is not affected by PMCR_EL0.FZS.</para>
<para>For more information, see <xref linkend="#CACDDJIEI5">'Prohibiting event and cycle counting'</xref>.</para></field_description>
    <field_values impdef="False">
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Cycle counting by <register_link state="AArch64" id="AArch64-pmccntr_el0.xml">PMCCNTR_EL0</register_link> is not affected by this mechanism.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description><para>Cycle counting by <register_link state="AArch64" id="AArch64-pmccntr_el0.xml">PMCCNTR_EL0</register_link> is disabled in prohibited regions and when event counting is frozen:</para>
<list type="unordered">
<listitem><content>If <xref linkend="#FEAT_PMUv3p1">FEAT_PMUv3p1</xref> is implemented, EL2 is implemented, and <register_link state="AArch64" id="AArch64-mdcr_el2.xml">MDCR_EL2</register_link>.HPMD  is 1, then cycle counting by <register_link state="AArch64" id="AArch64-pmccntr_el0.xml">PMCCNTR_EL0</register_link> is disabled at EL2.</content>
</listitem><listitem><content>If <xref linkend="#FEAT_SPE_DPFZS">FEAT_SPE_DPFZS</xref> is implemented and event counting is frozen by PMCR_EL0.FZS, then cycle counting by <register_link state="AArch64" id="AArch64-pmccntr_el0.xml">PMCCNTR_EL0</register_link> is disabled.</content>
</listitem><listitem><content>If <xref linkend="#FEAT_PMUv3p7">FEAT_PMUv3p7</xref> is implemented and event counting is frozen by PMCR_EL0.FZO, then cycle counting by <register_link state="AArch64" id="AArch64-pmccntr_el0.xml">PMCCNTR_EL0</register_link> is disabled.</content>
</listitem><listitem><content>If <xref linkend="#FEAT_PMUv3p7">FEAT_PMUv3p7</xref> is implemented, EL3 is implemented, and <register_link state="AArch64" id="AArch64-mdcr_el3.xml">MDCR_EL3</register_link>.MPMX is 1, then cycle counting by <register_link state="AArch64" id="AArch64-pmccntr_el0.xml">PMCCNTR_EL0</register_link> is disabled at EL3.</content>
</listitem><listitem><content>If EL3 is implemented, <register_link state="AArch64" id="AArch64-mdcr_el3.xml">MDCR_EL3</register_link>.SPME  is 0, and either <xref linkend="#FEAT_PMUv3p7">FEAT_PMUv3p7</xref> is not implemented or <register_link state="AArch64" id="AArch64-mdcr_el3.xml">MDCR_EL3</register_link>.MPMX is 0, then cycle counting by <register_link state="AArch64" id="AArch64-pmccntr_el0.xml">PMCCNTR_EL0</register_link> is disabled at EL3 and in Secure state.</content>
</listitem></list></field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_standard_text>AU</field_reset_standard_text>
      </field_reset>
    </field_resets>
    <fields_condition>When EL3 is implemented or (FEAT_PMUv3p1 is implemented and EL2 is implemented)</fields_condition>
  </field>
  <field id="fieldset_0-5_5-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0">
    <field_msb>5</field_msb>
    <field_lsb>5</field_lsb>
    <rel_range>5</rel_range>
    <field_description order="before"/>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_0-4_4-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" reserved_type="RAZ/WI">
    <field_name>X</field_name>
    <field_msb>4</field_msb>
    <field_lsb>4</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Enable export of events in an <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> PMU event export bus.</para>
    </field_description>
    <field_description order="after"><para>This field enables the exporting of events over an <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> PMU event export bus to another device.</para>
<para>No events are exported when counting is prohibited.</para>
<para>This field does not affect the generation of Performance Monitors overflow interrupt requests or signaling to a cross-trigger interface (CTI) that can be implemented as signals exported from the PE.</para></field_description>
    <field_values impdef="False">
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Do not export events.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Export events where not prohibited.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_standard_text>AU</field_reset_standard_text>
      </field_reset>
    </field_resets>
    <fields_condition>When the implementation includes a PMU event export bus</fields_condition>
  </field>
  <field id="fieldset_0-4_4-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RAZ/WI">
    <field_msb>4</field_msb>
    <field_lsb>4</field_lsb>
    <rel_range>4</rel_range>
    <field_description order="before"/>
    <field_description order="before">
      <para>Reserved, RAZ/WI.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_0-3_3-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" reserved_type="RES0">
    <field_name>D</field_name>
    <field_msb>3</field_msb>
    <field_lsb>3</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Clock divider.</para>
    </field_description>
    <field_description order="after"><para>If the Effective value of PMCR_EL0.LC is 1, then this field is ignored and the cycle counter counts every clock cycle.</para>
<para>Arm deprecates use of PMCR_EL0.D = 1.</para></field_description>
    <field_values impdef="False">
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>When enabled, <register_link state="AArch64" id="AArch64-pmccntr_el0.xml">PMCCNTR_EL0</register_link> counts every clock cycle.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>When enabled, <register_link state="AArch64" id="AArch64-pmccntr_el0.xml">PMCCNTR_EL0</register_link> counts once every 64 clock cycles.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_standard_text>AU</field_reset_standard_text>
      </field_reset>
    </field_resets>
    <fields_condition>When FEAT_AA32 is implemented</fields_condition>
  </field>
  <field id="fieldset_0-3_3-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0">
    <field_msb>3</field_msb>
    <field_lsb>3</field_lsb>
    <rel_range>3</rel_range>
    <field_description order="before"/>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_0-2_2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False">
    <field_name>C</field_name>
    <field_msb>2</field_msb>
    <field_lsb>2</field_lsb>
    <rel_range>2</rel_range>
    <field_description order="before">
      <para>Cycle counter reset. The effects of writing to this field are:</para>
    </field_description>
    <field_description order="after">
      <note>
        <para>Resetting <register_link state="AArch64" id="AArch64-pmccntr_el0.xml">PMCCNTR_EL0</register_link> does not change the cycle counter overflow field. The value of PMCR_EL0.LC is ignored, and bits [63:0] of the cycle counter are reset.</para>
      </note>
    </field_description>
    <field_values impdef="False">
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>No action.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Reset <register_link state="AArch64" id="AArch64-pmccntr_el0.xml">PMCCNTR_EL0</register_link> to zero.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_access>
      <field_access_state>
        <field_access_type>WO/RAZ</field_access_type>
      </field_access_state>
    </field_access>
  </field>
  <field id="fieldset_0-1_1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False">
    <field_name>P</field_name>
    <field_msb>1</field_msb>
    <field_lsb>1</field_lsb>
    <rel_range>1</rel_range>
    <field_description order="before">
      <para>Event counter reset.</para>
    </field_description>
    <field_description order="after"><para>The event counters affected by this field are:</para>
<list type="unordered">
<listitem><content>All event counters in the first range.</content>
</listitem><listitem><content>If any of the following are true, all event counters in the second range:<list type="unordered">
<listitem><content>EL2 is disabled or not implemented in the current Security state.</content>
</listitem><listitem><content>The PE is executing at EL2 or EL3.</content>
</listitem></list>
</content>
</listitem></list>
<para>Writes to this field do not affect other event counters, the cycle counter <register_link state="AArch64" id="AArch64-pmccntr_el0.xml">PMCCNTR_EL0</register_link>, or the instruction counter <register_link state="AArch64" id="AArch64-pmicntr_el0.xml">PMICNTR_EL0</register_link>.</para>
<para>For more information about event counter ranges, see <register_link state="AArch64" id="AArch64-mdcr_el2.xml">MDCR_EL2</register_link>.HPMN.</para>
<note><para>Resetting the event counters does not change the event counter overflow fields. If <xref linkend="#FEAT_PMUv3p5">FEAT_PMUv3p5</xref> is implemented, the values of <register_link state="AArch64" id="AArch64-mdcr_el2.xml">MDCR_EL2</register_link>.HLP  and PMCR_EL0.LP are ignored, and bits [63:0] of all affected event counters are reset.</para></note></field_description>
    <field_values impdef="False">
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>No action.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Reset all affected event counters <register_link state="AArch64" id="AArch64-pmevcntrn_el0.xml">PMEVCNTR&lt;n&gt;_EL0</register_link> to zero.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_access>
      <field_access_state>
        <field_access_type>WO/RAZ</field_access_type>
      </field_access_state>
    </field_access>
  </field>
  <field id="fieldset_0-0_0" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False">
    <field_name>E</field_name>
    <field_msb>0</field_msb>
    <field_lsb>0</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Enable.</para>
    </field_description>
    <field_description order="after"><para>The counters affected by this field are:</para>
<list type="unordered">
<listitem><content>The event counters in the first range.
For more information about event counter ranges, see <register_link state="AArch64" id="AArch64-mdcr_el2.xml">MDCR_EL2</register_link>.HPMN.</content>
</listitem><listitem><content>If <xref linkend="#FEAT_PMUv3_ICNTR">FEAT_PMUv3_ICNTR</xref> is implemented, the instruction counter <register_link state="AArch64" id="AArch64-pmicntr_el0.xml">PMICNTR_EL0</register_link>.</content>
</listitem><listitem><content>The cycle counter <register_link state="AArch64" id="AArch64-pmccntr_el0.xml">PMCCNTR_EL0</register_link>.</content>
</listitem></list>
<para>Other event counters are not affected by this field.</para></field_description>
    <field_values impdef="False">
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Affected counters are disabled and do not count.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Affected counters are enabled by <register_link state="AArch64" id="AArch64-pmcntenset_el0.xml">PMCNTENSET_EL0</register_link>.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_number>'0'</field_reset_number>
      </field_reset>
    </field_resets>
  </field>
  <text_after_fields/>
</fields>




    
<reg_fieldset length="64">
  <fieldat id="fieldset_0-63_33" msb="63" lsb="33"/>
  <fieldat id="fieldset_0-32_32-1" msb="32" lsb="32"/>
  <fieldat id="fieldset_0-31_24-1" msb="31" lsb="24"/>
  <fieldat id="fieldset_0-23_16-1" msb="23" lsb="16"/>
  <fieldat id="fieldset_0-15_11" msb="15" lsb="11"/>
  <fieldat id="fieldset_0-10_10" msb="10" lsb="10"/>
  <fieldat id="fieldset_0-9_9-1" msb="9" lsb="9"/>
  <fieldat id="fieldset_0-8_8" msb="8" lsb="8"/>
  <fieldat id="fieldset_0-7_7-1" msb="7" lsb="7"/>
  <fieldat id="fieldset_0-6_6-1" msb="6" lsb="6"/>
  <fieldat id="fieldset_0-5_5-1" msb="5" lsb="5"/>
  <fieldat id="fieldset_0-4_4-1" msb="4" lsb="4"/>
  <fieldat id="fieldset_0-3_3-1" msb="3" lsb="3"/>
  <fieldat id="fieldset_0-2_2" msb="2" lsb="2"/>
  <fieldat id="fieldset_0-1_1" msb="1" lsb="1"/>
  <fieldat id="fieldset_0-0_0" msb="0" lsb="0"/>
</reg_fieldset>


      </reg_fieldsets>

      <access_mechanisms>
          






    
        
        <access_mechanism accessor="MRS PMCR_EL0" type="SystemAccessor">
            <encoding>
            <access_instruction>MRS &lt;Xt&gt;, PMCR_EL0</access_instruction>
                
                <enc n="op0" v="0b11"/>
                
                <enc n="op1" v="0b011"/>
                
                <enc n="CRn" v="0b1001"/>
                
                <enc n="CRm" v="0b1100"/>
                
                <enc n="op2" v="0b000"/>
            </encoding>
            <access_permission>
                <ps name="MRS" sections="1" secttype="access_permission">
                <pstext>
if !(IsFeatureImplemented(FEAT_PMUv3) &amp;&amp; IsFeatureImplemented(FEAT_AA64)) then
    UNDEFINED;
elsif PSTATE.EL == EL0 then
    if HaveEL(EL3) &amp;&amp; EL3SDDUndefPriority() &amp;&amp; MDCR_EL3.TPM == '1' then
        UNDEFINED;
    elsif PMUSERENR_EL0.EN == '0' || (IsFeatureImplemented(FEAT_PMUv3p9) &amp;&amp; PMUSERENR_EL0.UEN == '1') then
        if EL2Enabled() &amp;&amp; HCR_EL2.TGE == '1' then
            AArch64.SystemAccessTrap(EL2, 0x18);
        else
            AArch64.SystemAccessTrap(EL1, 0x18);
    elsif EL2Enabled() &amp;&amp; MDCR_EL2.TPM == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; MDCR_EL2.TPMCR == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif HaveEL(EL3) &amp;&amp; MDCR_EL3.TPM == '1' then
        if EL3SDDUndef() then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x18);
    else
        X[t, 64] = PMCR_EL0;
elsif PSTATE.EL == EL1 then
    if HaveEL(EL3) &amp;&amp; EL3SDDUndefPriority() &amp;&amp; MDCR_EL3.TPM == '1' then
        UNDEFINED;
    elsif EL2Enabled() &amp;&amp; MDCR_EL2.TPM == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; MDCR_EL2.TPMCR == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif HaveEL(EL3) &amp;&amp; MDCR_EL3.TPM == '1' then
        if EL3SDDUndef() then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x18);
    else
        X[t, 64] = PMCR_EL0;
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; EL3SDDUndefPriority() &amp;&amp; MDCR_EL3.TPM == '1' then
        UNDEFINED;
    elsif HaveEL(EL3) &amp;&amp; MDCR_EL3.TPM == '1' then
        if EL3SDDUndef() then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x18);
    else
        X[t, 64] = PMCR_EL0;
elsif PSTATE.EL == EL3 then
    X[t, 64] = PMCR_EL0;
                </pstext>
                </ps>
            </access_permission>
        </access_mechanism>
    
        
        <access_mechanism accessor="MSRregister PMCR_EL0" type="SystemAccessor">
            <encoding>
            <access_instruction>MSR PMCR_EL0, &lt;Xt&gt;</access_instruction>
                
                <enc n="op0" v="0b11"/>
                
                <enc n="op1" v="0b011"/>
                
                <enc n="CRn" v="0b1001"/>
                
                <enc n="CRm" v="0b1100"/>
                
                <enc n="op2" v="0b000"/>
            </encoding>
            <access_permission>
                <ps name="MSRregister" sections="1" secttype="access_permission">
                <pstext>
if !(IsFeatureImplemented(FEAT_PMUv3) &amp;&amp; IsFeatureImplemented(FEAT_AA64)) then
    UNDEFINED;
elsif PSTATE.EL == EL0 then
    if HaveEL(EL3) &amp;&amp; EL3SDDUndefPriority() &amp;&amp; MDCR_EL3.TPM == '1' then
        UNDEFINED;
    elsif PMUSERENR_EL0.EN == '0' || (IsFeatureImplemented(FEAT_PMUv3p9) &amp;&amp; PMUSERENR_EL0.UEN == '1') then
        if EL2Enabled() &amp;&amp; HCR_EL2.TGE == '1' then
            AArch64.SystemAccessTrap(EL2, 0x18);
        else
            AArch64.SystemAccessTrap(EL1, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELIsInHost(EL0) &amp;&amp; IsFeatureImplemented(FEAT_FGT) &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HDFGWTR_EL2.PMCR_EL0 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; MDCR_EL2.TPM == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; MDCR_EL2.TPMCR == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif HaveEL(EL3) &amp;&amp; MDCR_EL3.TPM == '1' then
        if EL3SDDUndef() then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x18);
    else
        PMCR_EL0 = X[t, 64];
elsif PSTATE.EL == EL1 then
    if HaveEL(EL3) &amp;&amp; EL3SDDUndefPriority() &amp;&amp; MDCR_EL3.TPM == '1' then
        UNDEFINED;
    elsif EL2Enabled() &amp;&amp; IsFeatureImplemented(FEAT_FGT) &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HDFGWTR_EL2.PMCR_EL0 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; MDCR_EL2.TPM == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; MDCR_EL2.TPMCR == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif HaveEL(EL3) &amp;&amp; MDCR_EL3.TPM == '1' then
        if EL3SDDUndef() then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x18);
    else
        PMCR_EL0 = X[t, 64];
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; EL3SDDUndefPriority() &amp;&amp; MDCR_EL3.TPM == '1' then
        UNDEFINED;
    elsif HaveEL(EL3) &amp;&amp; MDCR_EL3.TPM == '1' then
        if EL3SDDUndef() then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x18);
    else
        PMCR_EL0 = X[t, 64];
elsif PSTATE.EL == EL3 then
    PMCR_EL0 = X[t, 64];
                </pstext>
                </ps>
            </access_permission>
        </access_mechanism>

      </access_mechanisms>

      <arch_variants>
      </arch_variants>
  </register>
</registers>

    <timestamp>21/03/2025 17:52; 154105dd5041532b480d9ef0c018b8420cbe5c19</timestamp>
</register_page>