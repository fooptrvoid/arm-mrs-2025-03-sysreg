<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:ext="http://exslt.org/common">
  <head>
    <title>PMSCR_EL2</title>
    <link href="insn.css" rel="stylesheet" type="text/css"/>
  </head>
  <body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">PMSCR_EL2, Statistical Profiling Control Register (EL2)</h1><p>The PMSCR_EL2 characteristics are:</p><h2>Purpose</h2>
        <p>Provides EL2 controls for Statistical Profiling.</p>
      <h2>Configuration</h2><p>This register is present only when FEAT_SPE is implemented. Otherwise, direct accesses to PMSCR_EL2 are <span class="arm-defined-word">UNDEFINED</span>.</p>
        <p>If EL2 is not implemented, this register is <span class="arm-defined-word">RES0</span> from EL3.</p>
      <h2>Attributes</h2>
        <p>PMSCR_EL2 is a 64-bit register.</p>
      <h2>Field descriptions</h2><table class="regdiagram" id="fieldset_0"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot><tbody><tr class="firstrow"><td class="lr" colspan="32"><a href="#fieldset_0-63_12">RES0</a></td></tr><tr class="firstrow"><td class="lr" colspan="20"><a href="#fieldset_0-63_12">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-11_11-1">EnVM</a></td><td class="lr" colspan="1"><a href="#fieldset_0-10_10-1">KE</a></td><td class="lr" colspan="2"><a href="#fieldset_0-9_8-1">EE</a></td><td class="lr" colspan="2"><a href="#fieldset_0-7_6">PCT</a></td><td class="lr" colspan="1"><a href="#fieldset_0-5_5">TS</a></td><td class="lr" colspan="1"><a href="#fieldset_0-4_4">PA</a></td><td class="lr" colspan="1"><a href="#fieldset_0-3_3">CX</a></td><td class="lr" colspan="1"><a href="#fieldset_0-2_2">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-1_1">E2SPE</a></td><td class="lr" colspan="1"><a href="#fieldset_0-0_0">E0HSPE</a></td></tr></tbody></table><h4 id="fieldset_0-63_12">Bits [63:12]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-11_11-1">EnVM, bit [11]<span class="condition"><br/>When FEAT_SPE_nVM is implemented:
                        </span></h4><div class="field">
      <p>Enable use of physical address Profiling Buffer pointers.</p>
    <table class="valuetable"><tr><th>EnVM</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Use of physical address Profiling Buffer pointers is disabled. The PE behaves as if <a href="AArch64-pmblimitr_el1.html">PMBLIMITR_EL1</a>.nVM is 0.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Use of physical address Profiling Buffer pointers is permitted.</p>
        </td></tr></table>
      <p>If EL2 is disabled in the owning Security state, or the owning Exception level is EL2, then the Effective value of this field is 1.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-11_11-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-10_10-1">KE, bit [10]<span class="condition"><br/>When FEAT_SPE_EXC is implemented:
                        </span></h4><div class="field">
      <p>Kernel exception enable for SPE Profiling exceptions taken to EL2.</p>
    <table class="valuetable"><tr><th>KE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>SPE Profiling exceptions taken to EL2 are always masked at EL2.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Enabled SPE Profiling exceptions taken to EL2 are masked at EL2 when PSTATE.PM is 1 and unmasked when PSTATE.PM is 0.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-10_10-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-9_8-1">EE, bits [9:8]<span class="condition"><br/>When FEAT_SPE_EXC is implemented:
                        </span></h4><div class="field">
      <p>Exception Enable.</p>
    <table class="valuetable"><tr><th>EE</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td><p>Disabled. SPE Profiling exceptions for EL2 and EL1 are disabled. All of the following apply:</p>
<ul>
<li>No Profiling Buffer management events are recorded in <a href="AArch64-pmbsr_el2.html">PMBSR_EL2</a>.
</li><li>Unless enabled by a higher Exception level, SPE Profiling exceptions are not generated.
</li><li><a href="AArch64-pmbsr_el1.html">PMBSR_EL1</a>.S drives the interrupt request signal <span class="signal">PMBIRQ</span>.
</li><li>Accesses to <a href="AArch64-pmbsr_el1.html">PMBSR_EL1</a> at EL1 ignore the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.NV1 and accesses to <a href="AArch64-pmbsr_el1.html">PMBSR_EL1</a> at EL2 ignore the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.E2H.
</li></ul></td></tr><tr><td class="bitfield">0b01</td><td><p>Delegated. SPE Profiling exceptions for EL2 are disabled, but might be enabled for  EL1 by  <a href="AArch64-pmscr_el1.html">PMSCR_EL1</a>.EE. All of the following apply:</p>
<ul>
<li>No Profiling Buffer management events are recorded in <a href="AArch64-pmbsr_el2.html">PMBSR_EL2</a>.
</li><li><a href="AArch64-pmbsr_el2.html">PMBSR_EL2</a>.S is ignored and SPE Profiling exceptions are not taken to EL2, other than for the case when the Effective value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE is 1.
</li></ul></td></tr><tr><td class="bitfield">0b10</td><td><p>Enabled. SPE Profiling exceptions for EL2 are enabled for Profiling Buffer management events targeting EL2, as follows:</p>
<ul>
<li>Profiling Buffer management events due to a fault on a write to the Profiling Buffer that would generate a Data Abort exception taken to EL2 if generated by a store instruction executed at the owning Exception level are recorded in <a href="AArch64-pmbsr_el2.html">PMBSR_EL2</a>, unless they are configured to be recorded in <a href="AArch64-pmbsr_el3.html">PMBSR_EL3</a> by <a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.PMSEE.
    If the owning Exception level is EL2, this means any fault on a write to the Profiling Buffer.
    If the owning Exception level is EL1, this means any of the following faults on a write to the Profiling Buffer:<ul>
<li>Stage 2 faults.
</li><li>If <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TEA is 1, synchronous External aborts.
</li><li>If <a href="AArch64-hcr_el2.html">HCR_EL2</a>.GPF is 1, Granule Protection Faults (GPFs).
</li></ul>

</li><li>Profiling Buffer management events due to Granule Protection Check faults other than GPFs on a write to the Profiling Buffer are recorded in <a href="AArch64-pmbsr_el2.html">PMBSR_EL2</a>, unless they are configured to be recorded in <a href="AArch64-pmbsr_el3.html">PMBSR_EL3</a> by <a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.PMSEE.
</li><li>SPE Profiling exceptions are generated and taken to EL2 when unmasked and <a href="AArch64-pmbsr_el2.html">PMBSR_EL2</a>.S is 1.
</li></ul></td></tr><tr><td class="bitfield">0b11</td><td><p>Trap all. SPE Profiling exceptions for EL2 are enabled for all Profiling Buffer management events, as follows:</p>
<ul>
<li>All Profiling Buffer management events are recorded in <a href="AArch64-pmbsr_el2.html">PMBSR_EL2</a>, unless they are configured to be recorded in <a href="AArch64-pmbsr_el3.html">PMBSR_EL3</a> by <a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.PMSEE.
</li><li>SPE Profiling exceptions are generated and taken to EL2 when unmasked and <a href="AArch64-pmbsr_el2.html">PMBSR_EL2</a>.S is 1.
</li></ul></td></tr></table>
      <p>If the Effective value of <a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.PMSEE is <span class="binarynumber">0b00</span>, then the Effective value of <a href="AArch64-pmscr_el2.html">PMSCR_EL2</a>.EE is <span class="binarynumber">0b00</span>. Otherwise, if EL2 is not implemented or the Effective value of <a href="AArch64-scr_el3.html">SCR_EL3</a>.{NS, EEL2} is {0, 0}, then the Effective value of <a href="AArch64-pmscr_el2.html">PMSCR_EL2</a>.EE is <span class="binarynumber">0b01</span>.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset:<ul>
            <li>When the highest implemented Exception level is EL2,
            this field resets to
            <span class="binarynumber">'00'</span>.
</li>
          
            <li>Otherwise,
            this field resets to
            an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li>
          </ul></li></ul></div><h4 id="fieldset_0-9_8-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-7_6">PCT, bits [7:6]</h4><div class="field"><p>Physical Timestamp. If timestamp sampling is enabled, determines which counter is collected. The behavior depends on the Profiling Buffer owning Exception level.</p>
<p>If <span class="xref">FEAT_ECV</span> is implemented, this is a two-bit field as shown. Otherwise, bit[7] is <span class="arm-defined-word">RES0</span>.</p><table class="valuetable"><tr><th>PCT</th><th>Meaning</th><th>Applies when</th></tr><tr><td class="bitfield">0b00</td><td><p>Virtual timestamp. The collected timestamp is the physical counter minus a virtual offset. If any of the following are true, the virtual offset is zero, otherwise the virtual offset is the value of <a href="AArch64-cntvoff_el2.html">CNTVOFF_EL2</a>:</p>
<ul>
<li>The sampled operation executed at EL2 and the Effective value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.E2H is 1.
</li><li>The sampled operation executed at EL0 and the Effective value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} is {1, 1}.
</li></ul>
<div class="note"><span class="note-header">Note</span><p>If the Profiling Buffer owning Exception level is EL1, the virtual offset is always <a href="AArch64-cntvoff_el2.html">CNTVOFF_EL2</a>.</p></div></td></tr><tr><td class="bitfield">0b01</td><td><p>If the Profiling Buffer owning Exception level is EL1, then the timestamp value is selected by <a href="AArch64-pmscr_el1.html">PMSCR_EL1</a>.PCT.</p>
<p>Otherwise, physical timestamp. The collected timestamp is the physical counter.</p></td></tr><tr><td class="bitfield">0b11</td><td><p>If the Profiling Buffer owning Exception level is EL1 and <a href="AArch64-pmscr_el1.html">PMSCR_EL1</a>.PCT == <span class="binarynumber">0b00</span>, then guest virtual timestamp. The collected timestamp is the physical counter minus the value of <a href="AArch64-cntvoff_el2.html">CNTVOFF_EL2</a>.</p>
<p>Otherwise, guest physical timestamp. The collected timestamp is the physical counter minus a physical offset. If any of the following are true, the physical offset is zero, otherwise the physical offset is the value of <a href="AArch64-cntpoff_el2.html">CNTPOFF_EL2</a>:</p>
<ul>
<li><a href="AArch64-scr_el3.html">SCR_EL3</a>.ECVEn == 0.
</li><li><a href="AArch64-cnthctl_el2.html">CNTHCTL_EL2</a>.ECV == 0.
</li><li><span class="xref">FEAT_ECV_POFF</span> is not implemented.
</li></ul></td><td>When FEAT_ECV is implemented</td></tr></table><p>All other values are reserved.</p>
<p>If EL2 is not implemented or EL2 is disabled in the current Security state, then the Effective value of this field is <span class="binarynumber">0b01</span>, other than for a direct read of the register.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-5_5">TS, bit [5]</h4><div class="field">
      <p>Timestamp <ins>sample enable. Enables recording of a Timestamp packet when the owning Exception level is EL2.</ins><del>Enable.</del></p>
    <table class="valuetable"><tr><th>TS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Timestamp <ins>packet recording</ins><del>sampling</del> disabled.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Timestamp <ins>packet recording</ins><del>sampling</del> enabled.</p>
        </td></tr></table><p><del>This bit is ignored by the PE when any of the following are true:</del></p>
      <ul><del>
</del><li><del>
</del><p><del>The Profiling Buffer owning Exception level is EL1.</del></p><del>

</del></li><li><del>
</del><p><del>In Secure state, and either </del><span class="xref"><del>FEAT_SEL2</del></span><del> is not implemented or Secure EL2 is disabled.</del></p><del>

</del></li></ul><p><ins>This field is ignored by the PE when the Profiling Buffer owning Exception level is EL1. For more information, see </ins><span class="xref"><ins>'Controlling the data that is collected'</ins></span><ins>.</ins></p><ins>
    </ins><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-4_4">PA, bit [4]</h4><div class="field">
      <p>Physical Address Sample Enable.</p>
    <table class="valuetable"><tr><th>PA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Physical addresses are not collected.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Physical addresses are collected.</p>
        </td></tr></table><p>If the Profiling Buffer owning Exception level is EL1, and EL2 is enabled in the current Security state, this bit is combined with <a href="AArch64-pmscr_el1.html">PMSCR_EL1</a>.PA to determine which address is collected.</p>
<p>If EL2 is not implemented or EL2 is disabled in the current Security state, the PE ignores the value of this bit and behaves as if this bit is set to 1, other than for a direct read of the register.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-3_3">CX, bit [3]</h4><div class="field">
      <p><a href="AArch64-contextidr_el2.html">CONTEXTIDR_EL2</a> <ins>sample</ins><del>Sample</del> <ins>enable. Enables recording of a Context packet containing the value of</ins><del>Enable.</del> <a href="AArch64-contextidr_el2.html"><ins>CONTEXTIDR_EL2</ins></a><ins>.</ins></p>
    <table class="valuetable"><tr><th>CX</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p><a href="AArch64-contextidr_el2.html">CONTEXTIDR_EL2</a> <ins>recording</ins><del>is</del> <ins>disabled.</ins><del>not collected.</del></p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p><a href="AArch64-contextidr_el2.html">CONTEXTIDR_EL2</a> <ins>recording</ins><del>is</del> <ins>enabled.</ins><del>collected.</del></p>
        </td></tr></table><p><ins>The PE ignores the value of this field and </ins><a href="AArch64-contextidr_el2.html"><ins>CONTEXTIDR_EL2</ins></a><ins> is not recorded when EL2 is not implemented or EL2 is disabled in the current Security state.</ins></p>
<del>
    </del><p><ins>For</ins><del>If</del> <ins>more</ins><del>EL2</del> <ins>information</ins><del>is not implemented or EL2 is disabled in the current Security state</del>, <ins>see</ins><del>the PE ignores the value of this bit.</del> <span class="xref"><ins>'Controlling the data that is collected'</ins></span><ins>.</ins></p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-2_2">Bit [2]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-1_1">E2SPE, bit [1]</h4><div class="field">
      <p>EL2 Statistical Profiling Enable.</p>
    <table class="valuetable"><tr><th>E2SPE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Sampling disabled at EL2.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Sampling enabled at EL2.</p>
        </td></tr></table><p>This bit is <span class="arm-defined-word">RES0</span> if <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.E2PB != <span class="binarynumber">0b00</span>.</p>
<p>If EL2 is disabled in the current Security state, this bit is ignored by the PE.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-0_0">E0HSPE, bit [0]</h4><div class="field">
      <p>EL0 Statistical Profiling Enable.</p>
    <table class="valuetable"><tr><th>E0HSPE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Sampling disabled at EL0.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Sampling enabled at EL0.</p>
        </td></tr></table><p>If <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.E2PB != <span class="binarynumber">0b00</span>, this bit is <span class="arm-defined-word">RES0</span>.</p>
<p>If EL2 is implemented and enabled in the current Security state, this bit is ignored by the PE when <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE == 0.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><div class="access_mechanisms"><h2>Accessing PMSCR_EL2</h2><p>Accesses to this register use the following encodings in the System register encoding space:</p><div><h4 class="assembler">MRS &lt;Xt>, PMSCR_EL2</h4></div><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b100</td><td>0b1001</td><td>0b1001</td><td>0b000</td></tr></table><p class="pseudocode">
if !IsFeatureImplemented(FEAT_SPE) then
    UNDEFINED;
elsif PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EffectiveHCR_EL2_NVx() IN {'xx1'} then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; EL3SDDUndefPriority() &amp;&amp; (MDCR_EL3.NSPB[0] == '0' || MDCR_EL3.NSPB[1] != SCR_EL3.NS || (IsFeatureImplemented(FEAT_RME) &amp;&amp; MDCR_EL3.NSPBE != SCR_EL3.NSE)) then
        UNDEFINED;
    elsif HaveEL(EL3) &amp;&amp; (MDCR_EL3.NSPB[0] == '0' || MDCR_EL3.NSPB[1] != SCR_EL3.NS || (IsFeatureImplemented(FEAT_RME) &amp;&amp; MDCR_EL3.NSPBE != SCR_EL3.NSE)) then
        if EL3SDDUndef() then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x18);
    else
        X[t, 64] = PMSCR_EL2;
elsif PSTATE.EL == EL3 then
    X[t, 64] = PMSCR_EL2;
                </p><div><h4 class="assembler">MSR PMSCR_EL2, &lt;Xt></h4></div><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b100</td><td>0b1001</td><td>0b1001</td><td>0b000</td></tr></table><p class="pseudocode">
if !IsFeatureImplemented(FEAT_SPE) then
    UNDEFINED;
elsif PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EffectiveHCR_EL2_NVx() IN {'xx1'} then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; EL3SDDUndefPriority() &amp;&amp; (MDCR_EL3.NSPB[0] == '0' || MDCR_EL3.NSPB[1] != SCR_EL3.NS || (IsFeatureImplemented(FEAT_RME) &amp;&amp; MDCR_EL3.NSPBE != SCR_EL3.NSE)) then
        UNDEFINED;
    elsif HaveEL(EL3) &amp;&amp; (MDCR_EL3.NSPB[0] == '0' || MDCR_EL3.NSPB[1] != SCR_EL3.NS || (IsFeatureImplemented(FEAT_RME) &amp;&amp; MDCR_EL3.NSPBE != SCR_EL3.NSE)) then
        if EL3SDDUndef() then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x18);
    else
        PMSCR_EL2 = X[t, 64];
elsif PSTATE.EL == EL3 then
    PMSCR_EL2 = X[t, 64];
                </p><div><h4 class="assembler">MRS &lt;Xt>, PMSCR_EL1</h4></div><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b000</td><td>0b1001</td><td>0b1001</td><td>0b000</td></tr></table><p class="pseudocode">
if !IsFeatureImplemented(FEAT_SPE) then
    UNDEFINED;
elsif PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if HaveEL(EL3) &amp;&amp; EL3SDDUndefPriority() &amp;&amp; (MDCR_EL3.NSPB[0] == '0' || MDCR_EL3.NSPB[1] != SCR_EL3.NS || (IsFeatureImplemented(FEAT_RME) &amp;&amp; MDCR_EL3.NSPBE != SCR_EL3.NSE)) then
        UNDEFINED;
    elsif EL2Enabled() &amp;&amp; IsFeatureImplemented(FEAT_FGT) &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HDFGRTR_EL2.PMSCR_EL1 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; MDCR_EL2.TPMS == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif HaveEL(EL3) &amp;&amp; (MDCR_EL3.NSPB[0] == '0' || MDCR_EL3.NSPB[1] != SCR_EL3.NS || (IsFeatureImplemented(FEAT_RME) &amp;&amp; MDCR_EL3.NSPBE != SCR_EL3.NSE)) then
        if EL3SDDUndef() then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x18);
    elsif EffectiveHCR_EL2_NVx() IN {'111'} then
        X[t, 64] = NVMem[0x828];
    else
        X[t, 64] = PMSCR_EL1;
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; EL3SDDUndefPriority() &amp;&amp; (MDCR_EL3.NSPB[0] == '0' || MDCR_EL3.NSPB[1] != SCR_EL3.NS || (IsFeatureImplemented(FEAT_RME) &amp;&amp; MDCR_EL3.NSPBE != SCR_EL3.NSE)) then
        UNDEFINED;
    elsif HaveEL(EL3) &amp;&amp; (MDCR_EL3.NSPB[0] == '0' || MDCR_EL3.NSPB[1] != SCR_EL3.NS || (IsFeatureImplemented(FEAT_RME) &amp;&amp; MDCR_EL3.NSPBE != SCR_EL3.NSE)) then
        if EL3SDDUndef() then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x18);
    elsif ELIsInHost(EL2) then
        X[t, 64] = PMSCR_EL2;
    else
        X[t, 64] = PMSCR_EL1;
elsif PSTATE.EL == EL3 then
    X[t, 64] = PMSCR_EL1;
                </p><div><h4 class="assembler">MSR PMSCR_EL1, &lt;Xt></h4></div><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b000</td><td>0b1001</td><td>0b1001</td><td>0b000</td></tr></table><p class="pseudocode">
if !IsFeatureImplemented(FEAT_SPE) then
    UNDEFINED;
elsif PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if HaveEL(EL3) &amp;&amp; EL3SDDUndefPriority() &amp;&amp; (MDCR_EL3.NSPB[0] == '0' || MDCR_EL3.NSPB[1] != SCR_EL3.NS || (IsFeatureImplemented(FEAT_RME) &amp;&amp; MDCR_EL3.NSPBE != SCR_EL3.NSE)) then
        UNDEFINED;
    elsif EL2Enabled() &amp;&amp; IsFeatureImplemented(FEAT_FGT) &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HDFGWTR_EL2.PMSCR_EL1 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; MDCR_EL2.TPMS == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif HaveEL(EL3) &amp;&amp; (MDCR_EL3.NSPB[0] == '0' || MDCR_EL3.NSPB[1] != SCR_EL3.NS || (IsFeatureImplemented(FEAT_RME) &amp;&amp; MDCR_EL3.NSPBE != SCR_EL3.NSE)) then
        if EL3SDDUndef() then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x18);
    elsif EffectiveHCR_EL2_NVx() IN {'111'} then
        NVMem[0x828] = X[t, 64];
    else
        PMSCR_EL1 = X[t, 64];
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; EL3SDDUndefPriority() &amp;&amp; (MDCR_EL3.NSPB[0] == '0' || MDCR_EL3.NSPB[1] != SCR_EL3.NS || (IsFeatureImplemented(FEAT_RME) &amp;&amp; MDCR_EL3.NSPBE != SCR_EL3.NSE)) then
        UNDEFINED;
    elsif HaveEL(EL3) &amp;&amp; (MDCR_EL3.NSPB[0] == '0' || MDCR_EL3.NSPB[1] != SCR_EL3.NS || (IsFeatureImplemented(FEAT_RME) &amp;&amp; MDCR_EL3.NSPBE != SCR_EL3.NSE)) then
        if EL3SDDUndef() then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x18);
    elsif ELIsInHost(EL2) then
        PMSCR_EL2 = X[t, 64];
    else
        PMSCR_EL1 = X[t, 64];
elsif PSTATE.EL == EL3 then
    PMSCR_EL1 = X[t, 64];
                </p></div><hr class="bottom_line"/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions"><ins>21</ins><del>18</del>/03/2025 <ins>17</ins><del>10</del>:<ins>53</ins><del>59</del>; <ins>154105dd5041532b480d9ef0c018b8420cbe5c19</ins><del>6f6b106801db2310344984eeeac8a14477b4909e</del></p><p class="copyconf">Copyright © <ins>2010-2025</ins><del>2010-2024</del> Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body>
</html>
