<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE register_page SYSTEM "registers.dtd">
<!-- Copyright (c) 2010-2025 Arm Limited or its affiliates. All rights reserved. -->
<!-- This document is Non-Confidential. This document may only be used and distributed in accordance with the terms of the agreement entered into by Arm and the party that Arm delivered this document to. -->
<!--The data contained in this document is preliminary and subject to change or correction following further review. -->
<?xml-stylesheet href="one_register.xsl" type="text/xsl" ?>







<register_page>
  <registers>
  
    <register is_register="True" is_internal="False" is_stub_entry="False">
      <reg_short_name>PMCR_EL0</reg_short_name>
        
        <reg_long_name>Performance Monitors Control Register</reg_long_name>


        <reg_parent_link id="pmu.xml">PMU</reg_parent_link>

      
            <reg_condition otherwise="RES0">when FEAT_PMUv3_EXT is implemented</reg_condition>
      



    
    <reg_address
        external_access="False"
        mem_map_access="False"
        block_access="True"
        memory_access="True"
        table_id="PMUacccessor0"
    >
  
  <reg_frame>PMU</reg_frame>
  
    
    <reg_offset><hexnumber>0xE04</hexnumber></reg_offset>
    <reg_access>
    
        
      <reg_access_state>
          <reg_access_level>When DoubleLockStatus(), or !IsCorePowered(), or !AllowExternalPMUAccess()</reg_access_level>
          <reg_access_type>ERROR</reg_access_type>
      </reg_access_state>
        
      <reg_access_state>
          <reg_access_level>When (FEAT_PMUv3_EXTPMN is not implemented, or !IsMostSecureAccess(), or PMCCR.OSLO == 0) and OSLockStatus()</reg_access_level>
          <reg_access_type>ERROR</reg_access_type>
      </reg_access_state>
        
      <reg_access_state>
          <reg_access_level>When SoftwareLockStatus()</reg_access_level>
          <reg_access_type>RO</reg_access_type>
      </reg_access_state>
        
      <reg_access_state>
          <reg_access_type>RW</reg_access_type>
      </reg_access_state>
    </reg_access>
</reg_address>

    
    <reg_address
        external_access="False"
        mem_map_access="False"
        block_access="True"
        memory_access="True"
        table_id="PMUacccessor1"
    >
  
  <reg_frame>PMU</reg_frame>
  
    
    <reg_offset><hexnumber>0xE10</hexnumber></reg_offset>
    <reg_access>
    
        
      <reg_access_state>
          <reg_access_level>When DoubleLockStatus(), or !IsCorePowered(), or !AllowExternalPMUAccess()</reg_access_level>
          <reg_access_type>ERROR</reg_access_type>
      </reg_access_state>
        
      <reg_access_state>
          <reg_access_level>When (FEAT_PMUv3_EXTPMN is not implemented, or !IsMostSecureAccess(), or PMCCR.OSLO == 0) and OSLockStatus()</reg_access_level>
          <reg_access_type>ERROR</reg_access_type>
      </reg_access_state>
        
      <reg_access_state>
          <reg_access_type>RW</reg_access_type>
      </reg_access_state>
    </reg_access>
</reg_address>


          <reg_reset_value></reg_reset_value>

      <reg_mappings>
        



    
      
      <reg_mapping>
        
  

    

  

    <mapped_name filename="AArch64-pmcr_el0.xml">PMCR_EL0</mapped_name>
  <mapped_type>Architectural</mapped_type>
      <mapped_execution_state>AArch64</mapped_execution_state>
    <mapped_from_startbit>63</mapped_from_startbit>
    <mapped_from_endbit>32</mapped_from_endbit>
    <mapped_to_startbit>63</mapped_to_startbit>
    <mapped_to_endbit>32</mapped_to_endbit>
    <mapped_from_rangeset output="63:32">
      <range>
        <msb>63</msb>
        <lsb>32</lsb>
      </range>
    </mapped_from_rangeset>
    <mapped_to_rangeset output="63:32">
      <range>
        <msb>63</msb>
        <lsb>32</lsb>
      </range>
    </mapped_to_rangeset>

        <mapped_to_condition>when FEAT_PMUv3_EXT64 is implemented</mapped_to_condition>
      </reg_mapping>
    
      
      <reg_mapping>
        
  

    

  

    <mapped_name filename="AArch64-pmcr_el0.xml">PMCR_EL0</mapped_name>
  <mapped_type>Architectural</mapped_type>
      <mapped_execution_state>AArch64</mapped_execution_state>
    <mapped_from_startbit>31</mapped_from_startbit>
    <mapped_from_endbit>0</mapped_from_endbit>
    <mapped_to_startbit>31</mapped_to_startbit>
    <mapped_to_endbit>0</mapped_to_endbit>
    <mapped_from_rangeset output="31:0">
      <range>
        <msb>31</msb>
        <lsb>0</lsb>
      </range>
    </mapped_from_rangeset>
    <mapped_to_rangeset output="31:0">
      <range>
        <msb>31</msb>
        <lsb>0</lsb>
      </range>
    </mapped_to_rangeset>

      </reg_mapping>
    
      
      <reg_mapping>
        
  

    

  

    <mapped_name filename="AArch32-pmcr.xml">PMCR</mapped_name>
  <mapped_type>Architectural</mapped_type>
      <mapped_execution_state>AArch32</mapped_execution_state>
    <mapped_from_startbit>10</mapped_from_startbit>
    <mapped_from_endbit>0</mapped_from_endbit>
    <mapped_to_startbit>10</mapped_to_startbit>
    <mapped_to_endbit>0</mapped_to_endbit>
    <mapped_from_rangeset output="10:0">
      <range>
        <msb>10</msb>
        <lsb>0</lsb>
      </range>
    </mapped_from_rangeset>
    <mapped_to_rangeset output="10:0">
      <range>
        <msb>10</msb>
        <lsb>0</lsb>
      </range>
    </mapped_to_rangeset>

      </reg_mapping>

      </reg_mappings>

        <reg_purpose>
          
    
      <purpose_text>
        <para>Configures and controls the Performance Monitors counters.</para>
      </purpose_text>

        </reg_purpose>

      <reg_groups>
          <reg_group>PMU</reg_group>
      </reg_groups>
      <reg_configuration>
        
    
      <configuration_text>
        <para>PMCR_EL0 is in the Core power domain.</para>

      </configuration_text>
      <configuration_text>
        <para>This register is only partially mapped to the internal <register_link state="AArch32" id="AArch32-pmcr.xml">PMCR</register_link> System register. An external agent must use other means to discover the information held in <register_link state="AArch32" id="AArch32-pmcr.xml">PMCR</register_link>[31:11], such as accessing <register_link id="pmu.pmcfgr.xml" state="">PMCFGR</register_link> and the ID registers.</para>
      </configuration_text>

      </reg_configuration>
      
      
        
      <reg_attributes>
          
    
      <attributes_text>
        <para>PMCR_EL0 is a:</para>

      </attributes_text>
      <attributes_text>
        <list type="unordered">
<listitem><content>64-bit register when FEAT_PMUv3_EXT64 is implemented</content>
</listitem><listitem><content>32-bit register otherwise</content>
</listitem></list>
      </attributes_text>

      </reg_attributes>
      <reg_fieldsets>
        





<fields id="fieldset_0" length="64">
  <fields_condition>When FEAT_PMUv3_EXT64 is implemented</fields_condition>
  <text_before_fields/>
  <field id="fieldset_0-63_33" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0">
    <field_msb>63</field_msb>
    <field_lsb>33</field_lsb>
    <rel_range>63:33</rel_range>
    <field_description order="before"/>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
  </field>
  <field id="fieldset_0-32_32-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" reserved_type="RES0">
    <field_name>FZS</field_name>
    <field_msb>32</field_msb>
    <field_lsb>32</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Freeze-on-SPE event. Stop counters when <register_link state="AArch64" id="AArch64-pmblimitr_el1.xml">PMBLIMITR_EL1</register_link>.{PMFZ,E} is {1,1} and profiling is stopped.</para>
    </field_description>
    <field_description order="after"><para>The pseudocode function <function>SPEProfilingStopped</function> describes when profiling is stopped.</para>
<para>The counters affected by this field are:</para>
<list type="unordered">
<listitem><content>The event counters in the first range.</content>
</listitem><listitem><content>If <xref linkend="#FEAT_PMUv3_ICNTR">FEAT_PMUv3_ICNTR</xref> is implemented, the instruction counter <register_link id="pmu.pmicntr_el0.xml" state="">PMICNTR_EL0</register_link>.</content>
</listitem><listitem><content>If <xref linkend="#FEAT_SPE_DPFZS">FEAT_SPE_DPFZS</xref> is implemented and PMCR_EL0.DP is 1, the cycle counter <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link>.</content>
</listitem></list>
<para>Other event counters are not affected by this field.</para>
<para>When <xref linkend="#FEAT_SPE_DPFZS">FEAT_SPE_DPFZS</xref> is not implemented or PMCR_EL0.DP is 0, <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link> is not affected by this field.</para>
<para>For more information about event counter ranges, see <register_link state="AArch64" id="AArch64-mdcr_el2.xml">MDCR_EL2</register_link>.HPMN.</para></field_description>
    <field_values impdef="False">
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Do not freeze on a Statistical Profiling Buffer Management event.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Affected counters do not count following a Statistical Profiling Buffer Management event.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_conditions>
          <field_reset_condition condition="FEAT_AA32 is implemented">
            <field_reset>
              <field_reset_number>'0'</field_reset_number>
            </field_reset>
          </field_reset_condition>
          <field_reset_condition>
            <field_reset>
              <field_reset_standard_text>AU</field_reset_standard_text>
            </field_reset>
          </field_reset_condition>
        </field_reset_conditions>
      </field_reset>
    </field_resets>
    <fields_condition>When FEAT_SPEv1p2 is implemented</fields_condition>
  </field>
  <field id="fieldset_0-32_32-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0">
    <field_msb>32</field_msb>
    <field_lsb>32</field_lsb>
    <rel_range>32</rel_range>
    <field_description order="before"/>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_0-31_11" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RAZ/WI">
    <field_msb>31</field_msb>
    <field_lsb>11</field_lsb>
    <rel_range>31:11</rel_range>
    <field_description order="before"/>
    <field_description order="before">
      <para>Reserved, RAZ/WI.</para>
    </field_description>
    <field_description order="after">
      <para>Hardware must implement this field as RAZ/WI. Software must not rely on the register reading as zero, and must use a read-modify-write sequence to write to the register.</para>
    </field_description>
  </field>
  <field id="fieldset_0-10_10" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0">
    <field_msb>10</field_msb>
    <field_lsb>10</field_lsb>
    <rel_range>10</rel_range>
    <field_description order="before"/>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
  </field>
  <field id="fieldset_0-9_9-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" reserved_type="RES0">
    <field_name>FZO</field_name>
    <field_msb>9</field_msb>
    <field_lsb>9</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Freeze-on-overflow. Stop event counters on overflow.</para>
    </field_description>
    <field_description order="after"><para>The counters affected by this field are:</para>
<list type="unordered">
<listitem><content>The event counters in the first range.</content>
</listitem><listitem><content>If <xref linkend="#FEAT_PMUv3_ICNTR">FEAT_PMUv3_ICNTR</xref> is implemented, the instruction counter <register_link id="pmu.pmicntr_el0.xml" state="">PMICNTR_EL0</register_link>.</content>
</listitem><listitem><content>If PMCR_EL0.DP is 1, the cycle counter <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link>.</content>
</listitem></list>
<para>Other event counters are not affected by this field.</para>
<para>When PMCR_EL0.DP is 0, <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link> is not affected by this field.</para>
<para>For more information about event counter ranges, see <register_link state="AArch64" id="AArch64-mdcr_el2.xml">MDCR_EL2</register_link>.HPMN.</para></field_description>
    <field_values impdef="False">
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Do not freeze on overflow.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description><para>Affected counters do not count when any of the following applies:</para>
<list type="unordered">
<listitem><content>
<para>For any event counter <register_link id="pmu.pmevcntrn_el0.xml" state="">PMEVCNTR&lt;m&gt;_EL0</register_link> in the first range, <register_link id="pmu.pmovsclr_el0.xml" state="">PMOVSCLR_EL0</register_link>[m] is 1, and either <xref linkend="#FEAT_SEBEP">FEAT_SEBEP</xref> is not implemented or <register_link id="pmu.pmevtypern_el0.xml" state="">PMEVTYPER&lt;m&gt;_EL0</register_link>.SYNC is 0.</para>
</content>
</listitem><listitem><content>
<para><xref linkend="#FEAT_PMUv3_ICNTR">FEAT_PMUv3_ICNTR</xref> is implemented, <register_link id="pmu.pmovsclr_el0.xml" state="">PMOVSCLR_EL0</register_link>.F0 is 1, and either <xref linkend="#FEAT_SEBEP">FEAT_SEBEP</xref> is not implemented or <register_link id="pmu.pmicfiltr_el0.xml" state="">PMICFILTR_EL0</register_link>.SYNC is 0.</para>
</content>
</listitem></list></field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_standard_text>AU</field_reset_standard_text>
      </field_reset>
    </field_resets>
    <fields_condition>When FEAT_PMUv3p7 is implemented</fields_condition>
  </field>
  <field id="fieldset_0-9_9-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0">
    <field_msb>9</field_msb>
    <field_lsb>9</field_lsb>
    <rel_range>9</rel_range>
    <field_description order="before"/>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_0-8_8" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0">
    <field_msb>8</field_msb>
    <field_lsb>8</field_lsb>
    <rel_range>8</rel_range>
    <field_description order="before"/>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
  </field>
  <field id="fieldset_0-7_7-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" reserved_type="RES0">
    <field_name>LP</field_name>
    <field_msb>7</field_msb>
    <field_lsb>7</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Long event counter enable. Determines when unsigned overflow is recorded by <register_link id="pmu.pmovsclr_el0.xml" state="">PMOVSCLR_EL0</register_link>.P[n].</para>
    </field_description>
    <field_description order="after"><para>When <xref linkend="#FEAT_EBEP">FEAT_EBEP</xref> is implemented and the PMU Profiling exception is enabled, the Effective value of this field is 1.</para>
<para>The counters affected by this field are the event counters in the first range.
For more information about event counter ranges, see <register_link state="AArch64" id="AArch64-mdcr_el2.xml">MDCR_EL2</register_link>.HPMN.</para>
<para>Other event counters and <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link> are not affected by this field.</para>
<para>When <xref linkend="#FEAT_PMUv3_ICNTR">FEAT_PMUv3_ICNTR</xref> is implemented, <register_link id="pmu.pmicntr_el0.xml" state="">PMICNTR_EL0</register_link> is not affected by this field.</para></field_description>
    <field_values impdef="False">
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Event counter overflow on increment that causes unsigned overflow of <register_link id="pmu.pmevcntrn_el0.xml" state="">PMEVCNTR&lt;n&gt;_EL0</register_link>[31:0].</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Event counter overflow on increment that causes unsigned overflow of <register_link id="pmu.pmevcntrn_el0.xml" state="">PMEVCNTR&lt;n&gt;_EL0</register_link>[63:0].</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_conditions>
          <field_reset_condition condition="FEAT_AA64 is not implemented">
            <field_reset>
              <field_reset_number>'0'</field_reset_number>
            </field_reset>
          </field_reset_condition>
          <field_reset_condition>
            <field_reset>
              <field_reset_standard_text>AU</field_reset_standard_text>
            </field_reset>
          </field_reset_condition>
        </field_reset_conditions>
      </field_reset>
    </field_resets>
    <fields_condition>When FEAT_PMUv3p5 is implemented</fields_condition>
  </field>
  <field id="fieldset_0-7_7-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0">
    <field_msb>7</field_msb>
    <field_lsb>7</field_lsb>
    <rel_range>7</rel_range>
    <field_description order="before"/>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_0-6_6-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" reserved_type="RES1">
    <field_name>LC</field_name>
    <field_msb>6</field_msb>
    <field_lsb>6</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Long cycle counter enable. Determines when unsigned overflow is recorded by <register_link id="pmu.pmovsclr_el0.xml" state="">PMOVSCLR_EL0</register_link>.C.</para>
    </field_description>
    <field_description order="after"><para>When <xref linkend="#FEAT_EBEP">FEAT_EBEP</xref> is implemented and the PMU Profiling exception is enabled, the Effective value of this field is 1.</para>
<para>Arm deprecates use of PMCR_EL0.LC = 0.</para></field_description>
    <field_values impdef="False">
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Cycle counter overflow on increment that causes unsigned overflow of <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link>[31:0].</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Cycle counter overflow on increment that causes unsigned overflow of <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link>[63:0].</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_standard_text>AU</field_reset_standard_text>
      </field_reset>
    </field_resets>
    <fields_condition>When FEAT_AA32 is implemented</fields_condition>
  </field>
  <field id="fieldset_0-6_6-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES1">
    <field_msb>6</field_msb>
    <field_lsb>6</field_lsb>
    <rel_range>6</rel_range>
    <field_description order="before"/>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES1</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_0-5_5-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" reserved_type="RES0">
    <field_name>DP</field_name>
    <field_msb>5</field_msb>
    <field_lsb>5</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Disable cycle counter when event counting is prohibited.</para>
    </field_description>
    <field_description order="after"><para>The conditions when this field disables the cycle counter are the same as when event counting by an event counter  in the first range is prohibited or frozen.
For more information about event counter ranges, see <register_link state="AArch64" id="AArch64-mdcr_el2.xml">MDCR_EL2</register_link>.HPMN.</para>
<para>If <xref linkend="#FEAT_PMUv3p7">FEAT_PMUv3p7</xref> and <xref linkend="#FEAT_SPEv1p2">FEAT_SPEv1p2</xref> are implemented, meaning PMCR_EL0.FZS is implemented, and <xref linkend="#FEAT_SPE_DPFZS">FEAT_SPE_DPFZS</xref> is not implemented, then cycle counting by <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link> is not affected by PMCR_EL0.FZS.</para>
<para>For more information, see <xref linkend="#CACDDJIEI5">'Prohibiting event and cycle counting'</xref>.</para></field_description>
    <field_values impdef="False">
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Cycle counting by <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link> is not affected by this mechanism.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description><para>Cycle counting by <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link> is disabled in prohibited regions and when event counting is frozen:</para>
<list type="unordered">
<listitem><content>If <xref linkend="#FEAT_PMUv3p1">FEAT_PMUv3p1</xref> is implemented, EL2 is implemented, and <register_link state="AArch64" id="AArch64-mdcr_el2.xml">MDCR_EL2</register_link>.HPMD or <register_link state="AArch32" id="AArch32-hdcr.xml">HDCR</register_link>.HPMD is 1, then cycle counting by <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link> is disabled at EL2.</content>
</listitem><listitem><content>If <xref linkend="#FEAT_SPE_DPFZS">FEAT_SPE_DPFZS</xref> is implemented and event counting is frozen by PMCR_EL0.FZS, then cycle counting by <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link> is disabled.</content>
</listitem><listitem><content>If <xref linkend="#FEAT_PMUv3p7">FEAT_PMUv3p7</xref> is implemented and event counting is frozen by PMCR_EL0.FZO, then cycle counting by <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link> is disabled.</content>
</listitem><listitem><content>If <xref linkend="#FEAT_PMUv3p7">FEAT_PMUv3p7</xref> is implemented, EL3 is implemented and using AArch64, and <register_link state="AArch64" id="AArch64-mdcr_el3.xml">MDCR_EL3</register_link>.MPMX is 1, then cycle counting by <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link> is disabled at EL3.</content>
</listitem><listitem><content>If EL3 is implemented, <register_link state="AArch64" id="AArch64-mdcr_el3.xml">MDCR_EL3</register_link>.SPME or <register_link state="AArch32" id="AArch32-sdcr.xml">SDCR</register_link>.SPME is 0, and one of <xref linkend="#FEAT_PMUv3p7">FEAT_PMUv3p7</xref> is not implemented, EL3 is using AArch32, or <register_link state="AArch64" id="AArch64-mdcr_el3.xml">MDCR_EL3</register_link>.MPMX is 0, then cycle counting by <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link> is disabled at EL3 and in Secure state.</content>
</listitem></list></field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_conditions>
          <field_reset_condition condition="FEAT_AA64 is not implemented">
            <field_reset>
              <field_reset_number>'0'</field_reset_number>
            </field_reset>
          </field_reset_condition>
          <field_reset_condition>
            <field_reset>
              <field_reset_standard_text>AU</field_reset_standard_text>
            </field_reset>
          </field_reset_condition>
        </field_reset_conditions>
      </field_reset>
    </field_resets>
    <fields_condition>When EL3 is implemented or (FEAT_PMUv3p1 is implemented and EL2 is implemented)</fields_condition>
  </field>
  <field id="fieldset_0-5_5-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0">
    <field_msb>5</field_msb>
    <field_lsb>5</field_lsb>
    <rel_range>5</rel_range>
    <field_description order="before"/>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_0-4_4-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" reserved_type="RAZ/WI">
    <field_name>X</field_name>
    <field_msb>4</field_msb>
    <field_lsb>4</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Enable export of events in an <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> PMU event export bus.</para>
    </field_description>
    <field_description order="after"><para>This field enables the exporting of events over an <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> PMU event export bus to another device.</para>
<para>No events are exported when counting is prohibited.</para>
<para>This field does not affect the generation of Performance Monitors overflow interrupt requests or signaling to a cross-trigger interface (CTI) that can be implemented as signals exported from the PE.</para></field_description>
    <field_values impdef="False">
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Do not export events.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Export events where not prohibited.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_conditions>
          <field_reset_condition condition="FEAT_AA64 is not implemented">
            <field_reset>
              <field_reset_number>'0'</field_reset_number>
            </field_reset>
          </field_reset_condition>
          <field_reset_condition>
            <field_reset>
              <field_reset_standard_text>AU</field_reset_standard_text>
            </field_reset>
          </field_reset_condition>
        </field_reset_conditions>
      </field_reset>
    </field_resets>
    <fields_condition>When the implementation includes a PMU event export bus</fields_condition>
  </field>
  <field id="fieldset_0-4_4-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RAZ/WI">
    <field_msb>4</field_msb>
    <field_lsb>4</field_lsb>
    <rel_range>4</rel_range>
    <field_description order="before"/>
    <field_description order="before">
      <para>Reserved, RAZ/WI.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_0-3_3-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" reserved_type="RES0">
    <field_name>D</field_name>
    <field_msb>3</field_msb>
    <field_lsb>3</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Clock divider.</para>
    </field_description>
    <field_description order="after"><para>If the Effective value of PMCR_EL0.LC is 1, then this field is ignored and the cycle counter counts every clock cycle.</para>
<para>Arm deprecates use of PMCR_EL0.D = 1.</para></field_description>
    <field_values impdef="False">
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>When enabled, <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link> counts every clock cycle.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>When enabled, <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link> counts once every 64 clock cycles.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_conditions>
          <field_reset_condition condition="FEAT_AA64 is not implemented">
            <field_reset>
              <field_reset_number>'0'</field_reset_number>
            </field_reset>
          </field_reset_condition>
          <field_reset_condition>
            <field_reset>
              <field_reset_standard_text>AU</field_reset_standard_text>
            </field_reset>
          </field_reset_condition>
        </field_reset_conditions>
      </field_reset>
    </field_resets>
    <fields_condition>When FEAT_AA32 is implemented</fields_condition>
  </field>
  <field id="fieldset_0-3_3-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0">
    <field_msb>3</field_msb>
    <field_lsb>3</field_lsb>
    <rel_range>3</rel_range>
    <field_description order="before"/>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_0-2_2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False">
    <field_name>C</field_name>
    <field_msb>2</field_msb>
    <field_lsb>2</field_lsb>
    <rel_range>2</rel_range>
    <field_description order="before">
      <para>Cycle counter reset. The effects of writing to this field are:</para>
    </field_description>
    <field_description order="after">
      <note>
        <para>Resetting <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link> does not change the cycle counter overflow field. The value of PMCR_EL0.LC is ignored, and bits [63:0] of the cycle counter are reset.</para>
      </note>
    </field_description>
    <field_values impdef="False">
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>No action.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Reset <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link> to zero.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_access>
      <field_access_state>
        <field_access_type>WO/RAZ</field_access_type>
      </field_access_state>
    </field_access>
  </field>
  <field id="fieldset_0-1_1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False">
    <field_name>P</field_name>
    <field_msb>1</field_msb>
    <field_lsb>1</field_lsb>
    <rel_range>1</rel_range>
    <field_description order="before">
      <para>Event counter reset.</para>
    </field_description>
    <field_description order="after"><para>The event counters affected by this field are:</para>
<list type="unordered">
<listitem><content>If FEAT_PMUv3_EXTPMN is implemented and the access to this register is a Most secure access, all event counters.</content>
</listitem><listitem><content>Otherwise, only event counters in the first and second ranges.</content>
</listitem></list>
<para>Writes to this field do not affect other event counters, the cycle counter <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link>, or the instruction counter <register_link id="pmu.pmicntr_el0.xml" state="">PMICNTR_EL0</register_link>.</para>
<para>For more information about event counter ranges, see <register_link state="AArch64" id="AArch64-mdcr_el2.xml">MDCR_EL2</register_link>.HPMN.</para>
<note><para>Resetting the event counters does not change the event counter overflow fields. If <xref linkend="#FEAT_PMUv3p5">FEAT_PMUv3p5</xref> is implemented, the values of <register_link state="AArch64" id="AArch64-mdcr_el2.xml">MDCR_EL2</register_link>.HLP  or <register_link state="AArch32" id="AArch32-hdcr.xml">HDCR</register_link>.HLP and PMCR_EL0.LP are ignored, and bits [63:0] of all affected event counters are reset.</para></note></field_description>
    <field_values impdef="False">
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>No action.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Reset all affected event counters <register_link id="pmu.pmevcntrn_el0.xml" state="">PMEVCNTR&lt;n&gt;_EL0</register_link> to zero.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_access>
      <field_access_state>
        <field_access_type>WO/RAZ</field_access_type>
      </field_access_state>
    </field_access>
  </field>
  <field id="fieldset_0-0_0" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False">
    <field_name>E</field_name>
    <field_msb>0</field_msb>
    <field_lsb>0</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Enable.</para>
    </field_description>
    <field_description order="after"><para>The counters affected by this field are:</para>
<list type="unordered">
<listitem><content>The event counters in the first range.
For more information about event counter ranges, see <register_link state="AArch64" id="AArch64-mdcr_el2.xml">MDCR_EL2</register_link>.HPMN.</content>
</listitem><listitem><content>If <xref linkend="#FEAT_PMUv3_ICNTR">FEAT_PMUv3_ICNTR</xref> is implemented, the instruction counter <register_link id="pmu.pmicntr_el0.xml" state="">PMICNTR_EL0</register_link>.</content>
</listitem><listitem><content>The cycle counter <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link>.</content>
</listitem></list>
<para>Other event counters are not affected by this field.</para></field_description>
    <field_values impdef="False">
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Affected counters are disabled and do not count.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Affected counters are enabled by <register_link id="pmu.pmcntenset_el0.xml" state="">PMCNTENSET_EL0</register_link>.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_number>'0'</field_reset_number>
      </field_reset>
    </field_resets>
  </field>
  <text_after_fields/>
</fields>



<fields id="fieldset_1" length="32">
  <fields_condition/>
  <text_before_fields/>
  <field id="fieldset_1-31_11" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RAZ/WI">
    <field_msb>31</field_msb>
    <field_lsb>11</field_lsb>
    <rel_range>31:11</rel_range>
    <field_description order="before"/>
    <field_description order="before">
      <para>Reserved, RAZ/WI.</para>
    </field_description>
    <field_description order="after">
      <para>Hardware must implement this field as RAZ/WI. Software must not rely on the register reading as zero, and must use a read-modify-write sequence to write to the register.</para>
    </field_description>
  </field>
  <field id="fieldset_1-10_10" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0">
    <field_msb>10</field_msb>
    <field_lsb>10</field_lsb>
    <rel_range>10</rel_range>
    <field_description order="before"/>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
  </field>
  <field id="fieldset_1-9_9-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" reserved_type="RES0">
    <field_name>FZO</field_name>
    <field_msb>9</field_msb>
    <field_lsb>9</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Freeze-on-overflow. Stop event counters on overflow.</para>
    </field_description>
    <field_description order="after"><para>The counters affected by this field are:</para>
<list type="unordered">
<listitem><content>The event counters in the first range.</content>
</listitem><listitem><content>If <xref linkend="#FEAT_PMUv3_ICNTR">FEAT_PMUv3_ICNTR</xref> is implemented, the instruction counter <register_link id="pmu.pmicntr_el0.xml" state="">PMICNTR_EL0</register_link>.</content>
</listitem><listitem><content>If PMCR_EL0.DP is 1, the cycle counter <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link>.</content>
</listitem></list>
<para>Other event counters are not affected by this field.</para>
<para>When PMCR_EL0.DP is 0, <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link> is not affected by this field.</para>
<para>For more information about event counter ranges, see <register_link state="AArch64" id="AArch64-mdcr_el2.xml">MDCR_EL2</register_link>.HPMN.</para></field_description>
    <field_values impdef="False">
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Do not freeze on overflow.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description><para>Affected counters do not count when any of the following applies:</para>
<list type="unordered">
<listitem><content>
<para>For any event counter <register_link id="pmu.pmevcntrn_el0.xml" state="">PMEVCNTR&lt;m&gt;_EL0</register_link> in the first range, <register_link id="pmu.pmovsclr_el0.xml" state="">PMOVSCLR_EL0</register_link>[m] is 1, and either <xref linkend="#FEAT_SEBEP">FEAT_SEBEP</xref> is not implemented or <register_link id="pmu.pmevtypern_el0.xml" state="">PMEVTYPER&lt;m&gt;_EL0</register_link>.SYNC is 0.</para>
</content>
</listitem><listitem><content>
<para><xref linkend="#FEAT_PMUv3_ICNTR">FEAT_PMUv3_ICNTR</xref> is implemented, <register_link id="pmu.pmovsclr_el0.xml" state="">PMOVSCLR_EL0</register_link>.F0 is 1, and either <xref linkend="#FEAT_SEBEP">FEAT_SEBEP</xref> is not implemented or <register_link id="pmu.pmicfiltr_el0.xml" state="">PMICFILTR_EL0</register_link>.SYNC is 0.</para>
</content>
</listitem></list></field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_standard_text>AU</field_reset_standard_text>
      </field_reset>
    </field_resets>
    <fields_condition>When FEAT_PMUv3p7 is implemented</fields_condition>
  </field>
  <field id="fieldset_1-9_9-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0">
    <field_msb>9</field_msb>
    <field_lsb>9</field_lsb>
    <rel_range>9</rel_range>
    <field_description order="before"/>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_1-8_8" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0">
    <field_msb>8</field_msb>
    <field_lsb>8</field_lsb>
    <rel_range>8</rel_range>
    <field_description order="before"/>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
  </field>
  <field id="fieldset_1-7_7-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" reserved_type="RES0">
    <field_name>LP</field_name>
    <field_msb>7</field_msb>
    <field_lsb>7</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Long event counter enable. Determines when unsigned overflow is recorded by <register_link id="pmu.pmovsclr_el0.xml" state="">PMOVSCLR_EL0</register_link>.P[n].</para>
    </field_description>
    <field_description order="after"><para>When <xref linkend="#FEAT_EBEP">FEAT_EBEP</xref> is implemented and the PMU Profiling exception is enabled, the Effective value of this field is 1.</para>
<para>The counters affected by this field are the event counters in the first range.
For more information about event counter ranges, see <register_link state="AArch64" id="AArch64-mdcr_el2.xml">MDCR_EL2</register_link>.HPMN.</para>
<para>Other event counters and <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link> are not affected by this field.</para>
<para>When <xref linkend="#FEAT_PMUv3_ICNTR">FEAT_PMUv3_ICNTR</xref> is implemented, <register_link id="pmu.pmicntr_el0.xml" state="">PMICNTR_EL0</register_link> is not affected by this field.</para></field_description>
    <field_values impdef="False">
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Event counter overflow on increment that causes unsigned overflow of <register_link id="pmu.pmevcntrn_el0.xml" state="">PMEVCNTR&lt;n&gt;_EL0</register_link>[31:0].</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Event counter overflow on increment that causes unsigned overflow of <register_link id="pmu.pmevcntrn_el0.xml" state="">PMEVCNTR&lt;n&gt;_EL0</register_link>[63:0].</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_conditions>
          <field_reset_condition condition="FEAT_AA64 is not implemented">
            <field_reset>
              <field_reset_number>'0'</field_reset_number>
            </field_reset>
          </field_reset_condition>
          <field_reset_condition>
            <field_reset>
              <field_reset_standard_text>AU</field_reset_standard_text>
            </field_reset>
          </field_reset_condition>
        </field_reset_conditions>
      </field_reset>
    </field_resets>
    <fields_condition>When FEAT_PMUv3p5 is implemented</fields_condition>
  </field>
  <field id="fieldset_1-7_7-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0">
    <field_msb>7</field_msb>
    <field_lsb>7</field_lsb>
    <rel_range>7</rel_range>
    <field_description order="before"/>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_1-6_6-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" reserved_type="RES1">
    <field_name>LC</field_name>
    <field_msb>6</field_msb>
    <field_lsb>6</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Long cycle counter enable. Determines when unsigned overflow is recorded by <register_link id="pmu.pmovsclr_el0.xml" state="">PMOVSCLR_EL0</register_link>.C.</para>
    </field_description>
    <field_description order="after"><para>When <xref linkend="#FEAT_EBEP">FEAT_EBEP</xref> is implemented and the PMU Profiling exception is enabled, the Effective value of this field is 1.</para>
<para>Arm deprecates use of PMCR_EL0.LC = 0.</para></field_description>
    <field_values impdef="False">
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Cycle counter overflow on increment that causes unsigned overflow of <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link>[31:0].</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Cycle counter overflow on increment that causes unsigned overflow of <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link>[63:0].</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_standard_text>AU</field_reset_standard_text>
      </field_reset>
    </field_resets>
    <fields_condition>When FEAT_AA32 is implemented</fields_condition>
  </field>
  <field id="fieldset_1-6_6-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES1">
    <field_msb>6</field_msb>
    <field_lsb>6</field_lsb>
    <rel_range>6</rel_range>
    <field_description order="before"/>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES1</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_1-5_5-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" reserved_type="RES0">
    <field_name>DP</field_name>
    <field_msb>5</field_msb>
    <field_lsb>5</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Disable cycle counter when event counting is prohibited.</para>
    </field_description>
    <field_description order="after"><para>The conditions when this field disables the cycle counter are the same as when event counting by an event counter  in the first range is prohibited or frozen.
For more information about event counter ranges, see <register_link state="AArch64" id="AArch64-mdcr_el2.xml">MDCR_EL2</register_link>.HPMN.</para>
<para>If <xref linkend="#FEAT_PMUv3p7">FEAT_PMUv3p7</xref> and <xref linkend="#FEAT_SPEv1p2">FEAT_SPEv1p2</xref> are implemented, meaning PMCR_EL0.FZS is implemented, and <xref linkend="#FEAT_SPE_DPFZS">FEAT_SPE_DPFZS</xref> is not implemented, then cycle counting by <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link> is not affected by PMCR_EL0.FZS.</para>
<para>For more information, see <xref linkend="#CACDDJIEI5">'Prohibiting event and cycle counting'</xref>.</para></field_description>
    <field_values impdef="False">
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Cycle counting by <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link> is not affected by this mechanism.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description><para>Cycle counting by <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link> is disabled in prohibited regions and when event counting is frozen:</para>
<list type="unordered">
<listitem><content>If <xref linkend="#FEAT_PMUv3p1">FEAT_PMUv3p1</xref> is implemented, EL2 is implemented, and <register_link state="AArch64" id="AArch64-mdcr_el2.xml">MDCR_EL2</register_link>.HPMD or <register_link state="AArch32" id="AArch32-hdcr.xml">HDCR</register_link>.HPMD is 1, then cycle counting by <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link> is disabled at EL2.</content>
</listitem><listitem><content>If <xref linkend="#FEAT_SPE_DPFZS">FEAT_SPE_DPFZS</xref> is implemented and event counting is frozen by PMCR_EL0.FZS, then cycle counting by <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link> is disabled.</content>
</listitem><listitem><content>If <xref linkend="#FEAT_PMUv3p7">FEAT_PMUv3p7</xref> is implemented and event counting is frozen by PMCR_EL0.FZO, then cycle counting by <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link> is disabled.</content>
</listitem><listitem><content>If <xref linkend="#FEAT_PMUv3p7">FEAT_PMUv3p7</xref> is implemented, EL3 is implemented and using AArch64, and <register_link state="AArch64" id="AArch64-mdcr_el3.xml">MDCR_EL3</register_link>.MPMX is 1, then cycle counting by <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link> is disabled at EL3.</content>
</listitem><listitem><content>If EL3 is implemented, <register_link state="AArch64" id="AArch64-mdcr_el3.xml">MDCR_EL3</register_link>.SPME or <register_link state="AArch32" id="AArch32-sdcr.xml">SDCR</register_link>.SPME is 0, and one of <xref linkend="#FEAT_PMUv3p7">FEAT_PMUv3p7</xref> is not implemented, EL3 is using AArch32, or <register_link state="AArch64" id="AArch64-mdcr_el3.xml">MDCR_EL3</register_link>.MPMX is 0, then cycle counting by <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link> is disabled at EL3 and in Secure state.</content>
</listitem></list></field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_conditions>
          <field_reset_condition condition="FEAT_AA64 is not implemented">
            <field_reset>
              <field_reset_number>'0'</field_reset_number>
            </field_reset>
          </field_reset_condition>
          <field_reset_condition>
            <field_reset>
              <field_reset_standard_text>AU</field_reset_standard_text>
            </field_reset>
          </field_reset_condition>
        </field_reset_conditions>
      </field_reset>
    </field_resets>
    <fields_condition>When EL3 is implemented or (FEAT_PMUv3p1 is implemented and EL2 is implemented)</fields_condition>
  </field>
  <field id="fieldset_1-5_5-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0">
    <field_msb>5</field_msb>
    <field_lsb>5</field_lsb>
    <rel_range>5</rel_range>
    <field_description order="before"/>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_1-4_4-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" reserved_type="RAZ/WI">
    <field_name>X</field_name>
    <field_msb>4</field_msb>
    <field_lsb>4</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Enable export of events in an <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> PMU event export bus.</para>
    </field_description>
    <field_description order="after"><para>This field enables the exporting of events over an <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> PMU event export bus to another device.</para>
<para>No events are exported when counting is prohibited.</para>
<para>This field does not affect the generation of Performance Monitors overflow interrupt requests or signaling to a cross-trigger interface (CTI) that can be implemented as signals exported from the PE.</para></field_description>
    <field_values impdef="False">
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Do not export events.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Export events where not prohibited.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_conditions>
          <field_reset_condition condition="FEAT_AA64 is not implemented">
            <field_reset>
              <field_reset_number>'0'</field_reset_number>
            </field_reset>
          </field_reset_condition>
          <field_reset_condition>
            <field_reset>
              <field_reset_standard_text>AU</field_reset_standard_text>
            </field_reset>
          </field_reset_condition>
        </field_reset_conditions>
      </field_reset>
    </field_resets>
    <fields_condition>When the implementation includes a PMU event export bus</fields_condition>
  </field>
  <field id="fieldset_1-4_4-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RAZ/WI">
    <field_msb>4</field_msb>
    <field_lsb>4</field_lsb>
    <rel_range>4</rel_range>
    <field_description order="before"/>
    <field_description order="before">
      <para>Reserved, RAZ/WI.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_1-3_3-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" reserved_type="RES0">
    <field_name>D</field_name>
    <field_msb>3</field_msb>
    <field_lsb>3</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Clock divider.</para>
    </field_description>
    <field_description order="after"><para>If the Effective value of PMCR_EL0.LC is 1, then this field is ignored and the cycle counter counts every clock cycle.</para>
<para>Arm deprecates use of PMCR_EL0.D = 1.</para></field_description>
    <field_values impdef="False">
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>When enabled, <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link> counts every clock cycle.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>When enabled, <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link> counts once every 64 clock cycles.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_conditions>
          <field_reset_condition condition="FEAT_AA64 is not implemented">
            <field_reset>
              <field_reset_number>'0'</field_reset_number>
            </field_reset>
          </field_reset_condition>
          <field_reset_condition>
            <field_reset>
              <field_reset_standard_text>AU</field_reset_standard_text>
            </field_reset>
          </field_reset_condition>
        </field_reset_conditions>
      </field_reset>
    </field_resets>
    <fields_condition>When FEAT_AA32 is implemented</fields_condition>
  </field>
  <field id="fieldset_1-3_3-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0">
    <field_msb>3</field_msb>
    <field_lsb>3</field_lsb>
    <rel_range>3</rel_range>
    <field_description order="before"/>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_1-2_2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False">
    <field_name>C</field_name>
    <field_msb>2</field_msb>
    <field_lsb>2</field_lsb>
    <rel_range>2</rel_range>
    <field_description order="before">
      <para>Cycle counter reset. The effects of writing to this field are:</para>
    </field_description>
    <field_description order="after">
      <note>
        <para>Resetting <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link> does not change the cycle counter overflow field. The value of PMCR_EL0.LC is ignored, and bits [63:0] of the cycle counter are reset.</para>
      </note>
    </field_description>
    <field_values impdef="False">
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>No action.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Reset <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link> to zero.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_access>
      <field_access_state>
        <field_access_type>WO/RAZ</field_access_type>
      </field_access_state>
    </field_access>
  </field>
  <field id="fieldset_1-1_1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False">
    <field_name>P</field_name>
    <field_msb>1</field_msb>
    <field_lsb>1</field_lsb>
    <rel_range>1</rel_range>
    <field_description order="before">
      <para>Event counter reset.</para>
    </field_description>
    <field_description order="after"><para>The event counters affected by this field are:</para>
<list type="unordered">
<listitem><content>If FEAT_PMUv3_EXTPMN is implemented and the access to this register is a Most secure access, all event counters.</content>
</listitem><listitem><content>Otherwise, only event counters in the first and second ranges.</content>
</listitem></list>
<para>Writes to this field do not affect other event counters, the cycle counter <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link>, or the instruction counter <register_link id="pmu.pmicntr_el0.xml" state="">PMICNTR_EL0</register_link>.</para>
<para>For more information about event counter ranges, see <register_link state="AArch64" id="AArch64-mdcr_el2.xml">MDCR_EL2</register_link>.HPMN.</para>
<note><para>Resetting the event counters does not change the event counter overflow fields. If <xref linkend="#FEAT_PMUv3p5">FEAT_PMUv3p5</xref> is implemented, the values of <register_link state="AArch64" id="AArch64-mdcr_el2.xml">MDCR_EL2</register_link>.HLP  or <register_link state="AArch32" id="AArch32-hdcr.xml">HDCR</register_link>.HLP and PMCR_EL0.LP are ignored, and bits [63:0] of all affected event counters are reset.</para></note></field_description>
    <field_values impdef="False">
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>No action.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Reset all affected event counters <register_link id="pmu.pmevcntrn_el0.xml" state="">PMEVCNTR&lt;n&gt;_EL0</register_link> to zero.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_access>
      <field_access_state>
        <field_access_type>WO/RAZ</field_access_type>
      </field_access_state>
    </field_access>
  </field>
  <field id="fieldset_1-0_0" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False">
    <field_name>E</field_name>
    <field_msb>0</field_msb>
    <field_lsb>0</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Enable.</para>
    </field_description>
    <field_description order="after"><para>The counters affected by this field are:</para>
<list type="unordered">
<listitem><content>The event counters in the first range.
For more information about event counter ranges, see <register_link state="AArch64" id="AArch64-mdcr_el2.xml">MDCR_EL2</register_link>.HPMN.</content>
</listitem><listitem><content>If <xref linkend="#FEAT_PMUv3_ICNTR">FEAT_PMUv3_ICNTR</xref> is implemented, the instruction counter <register_link id="pmu.pmicntr_el0.xml" state="">PMICNTR_EL0</register_link>.</content>
</listitem><listitem><content>The cycle counter <register_link id="pmu.pmccntr_el0.xml" state="">PMCCNTR_EL0</register_link>.</content>
</listitem></list>
<para>Other event counters are not affected by this field.</para></field_description>
    <field_values impdef="False">
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Affected counters are disabled and do not count.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Affected counters are enabled by <register_link id="pmu.pmcntenset_el0.xml" state="">PMCNTENSET_EL0</register_link>.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_number>'0'</field_reset_number>
      </field_reset>
    </field_resets>
  </field>
  <text_after_fields/>
</fields>





    
<reg_fieldset length="64">
  <fields_condition>When FEAT_PMUv3_EXT64 is implemented</fields_condition>
  <fieldat id="fieldset_0-63_33" msb="63" lsb="33"/>
  <fieldat id="fieldset_0-32_32-1" msb="32" lsb="32"/>
  <fieldat id="fieldset_0-31_11" msb="31" lsb="11"/>
  <fieldat id="fieldset_0-10_10" msb="10" lsb="10"/>
  <fieldat id="fieldset_0-9_9-1" msb="9" lsb="9"/>
  <fieldat id="fieldset_0-8_8" msb="8" lsb="8"/>
  <fieldat id="fieldset_0-7_7-1" msb="7" lsb="7"/>
  <fieldat id="fieldset_0-6_6-1" msb="6" lsb="6"/>
  <fieldat id="fieldset_0-5_5-1" msb="5" lsb="5"/>
  <fieldat id="fieldset_0-4_4-1" msb="4" lsb="4"/>
  <fieldat id="fieldset_0-3_3-1" msb="3" lsb="3"/>
  <fieldat id="fieldset_0-2_2" msb="2" lsb="2"/>
  <fieldat id="fieldset_0-1_1" msb="1" lsb="1"/>
  <fieldat id="fieldset_0-0_0" msb="0" lsb="0"/>
</reg_fieldset>

    
<reg_fieldset length="32">
  <fields_condition/>
  <fieldat id="fieldset_1-31_11" msb="31" lsb="11"/>
  <fieldat id="fieldset_1-10_10" msb="10" lsb="10"/>
  <fieldat id="fieldset_1-9_9-1" msb="9" lsb="9"/>
  <fieldat id="fieldset_1-8_8" msb="8" lsb="8"/>
  <fieldat id="fieldset_1-7_7-1" msb="7" lsb="7"/>
  <fieldat id="fieldset_1-6_6-1" msb="6" lsb="6"/>
  <fieldat id="fieldset_1-5_5-1" msb="5" lsb="5"/>
  <fieldat id="fieldset_1-4_4-1" msb="4" lsb="4"/>
  <fieldat id="fieldset_1-3_3-1" msb="3" lsb="3"/>
  <fieldat id="fieldset_1-2_2" msb="2" lsb="2"/>
  <fieldat id="fieldset_1-1_1" msb="1" lsb="1"/>
  <fieldat id="fieldset_1-0_0" msb="0" lsb="0"/>
</reg_fieldset>


      </reg_fieldsets>

      <access_mechanisms>
          


  
    
      <access_permission_text>
        <note><para>SoftwareLockStatus() depends on the type of access attempted and AllowExternalPMUAccess() has a new definition from Armv8.4. Refer to the Pseudocode definitions for more information.</para></note>
      </access_permission_text>





    
        
        <access_mechanism type="BlockAccessAbstract" table_id="PMUacccessor0">
        
        
        
        
        <access_header>Accessible at offset <hexnumber>0xE04</hexnumber> from PMU</access_header>
        <access_condition>
When FEAT_PMUv3_EXT32 is implemented
        </access_condition>
    </access_mechanism>
    
        
        <access_mechanism type="BlockAccessAbstract" table_id="PMUacccessor1">
        
        
        
        
        <access_header>Accessible at offset <hexnumber>0xE10</hexnumber> from PMU</access_header>
        <access_condition>
When FEAT_PMUv3_EXT64 is implemented
        </access_condition>
    </access_mechanism>

      </access_mechanisms>

      <arch_variants>
      </arch_variants>
  </register>
</registers>

    <timestamp>21/03/2025 17:53; 154105dd5041532b480d9ef0c018b8420cbe5c19</timestamp>
</register_page>